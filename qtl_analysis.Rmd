---
title: "qtl_analysis"
author: "SERGIO PEREZ-LIMON"
date: "7/21/2021"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Load libraries, set seed and set working directory

```{r}
library(tidyverse)
library(googlesheets4)
library(googledrive)
library(qtl)
library(broom)
library(pals)

# Set the seed as the same value as previous analysis
set.seed(54955149)

# Note: don't forget to set working directory the same as project directory
```

Functions

```{r}

# transform p.value to significance codes
p.value_to_ast <- function(p.value) {
  
  ast <- case_when(
    p.value < 0.001 ~ "***",
    p.value >= 0.001 & p.value < 0.01 ~ "**",
    p.value >= 0.01 & p.value < 0.05 ~ "*",
    p.value >= 0.05 & p.value < 0.01 ~ ".",
    p.value > 0.01 ~ "NS",
    T ~ NA_character_)
  
  return(ast)
  
}
# raincloud plots function
raincloud_plot <- function(data, tissue) {
  
  plot <- data %>%
    ggplot(data =., 
           aes(x = hun, 
               y = value, 
               fill = hun)
           ) +
    ggdist::stat_halfeye(aes(fill = hun),
                         adjust = .5, 
                         width = .6, 
                         .width = 0, 
                         justification = -.2, 
                         point_colour = NA,
                         color = "black",
                         ) +
    geom_boxplot(
      width = .15, 
      outlier.shape = NA,
      color = "black"
      ) +
    gghalves::geom_half_point(
      ## draw jitter on the left
      side = "l", 
      ## control range of jitter
      range_scale = .4, 
      ## add some transparency
      alpha = .5,
      shape = 21,
      color = "black"
      ) +
    ggpubr::stat_compare_means(
      comparisons = list(c("HUN", "WT")),
      label = "p.signif",
      method = "wilcox.test") +
    xlab(NULL) +
    ylab("ppm") +
    theme(
      panel.background = element_rect(fill = "white", 
                                      colour ="grey50"),
      plot.title = element_text(hjust = 0.5),
      text = element_text(size=20)
      ) +
    scale_fill_manual(
      values = hun_color_scheme, guide = NULL
      ) +
    ggtitle(tissue)
  
  return(plot)
}
# transform summary and add information in a suitable tibble
summary.to.tibble <- function(CROSS, SCANONE, PERMS, ...) {
  
  a <- summary(
    object = SCANONE, 
    perms = PERMS,
    format = "tabByChr",
    ci.function = "lodint",
    ...
  ) 
  
  
  b <- summary(PERMS, ...)
  
  c <- tibble(
    phenotype = b %>% attr("dimnames") %>% .[[2]],
    threshold = b %>% as.numeric() %>% round(., 3)
  )
  
  p1 <- a %>%
    map_df(
      .x = ., 
      .f = ~ as_tibble(.x, rownames = "qtl"), 
      .id = "chr"
    ) %>%
    separate(
      qtl, 
      into = c("phenotype", "marker"), 
      sep = " : "
    ) %>%
    arrange(chr, pos, phenotype) %>%
    mutate(
      marker = map2_chr(
        .x = chr,
        .y = pos,
        .f = ~ find.marker(cross = CROSS,
                           chr = .x,
                           pos = .y)))
  
  p2 <- p1 %>%
    pivot_longer(c(pos, ci.low, ci.high)) %>%
    mutate(
      c_marker = map2_chr(
        .x = chr,
        .y = value,
        .f = ~ find.marker(
          cross = CROSS,       
          chr = .x,
          pos = .y
        )
      )) %>%
    mutate(c_marker = gsub("^\\d{1,}_", "", c_marker) %>% as.integer,
           c_marker = round(c_marker/1e6, 3),
           name = paste0("p_", name)) %>%
    select(-value) %>%
    pivot_wider(names_from = name, values_from = c_marker) %>%
    mutate(interval = p_ci.high - p_ci.low)
  
  p3 <- p1 %>%
    left_join(p2, by = c("phenotype", "marker", "chr", "lod")) %>%
    left_join(c, by = "phenotype")
  
  
  return(p3)
}
# transform results in df to use to plot in ggplot2
lodplot_map_df <- function(SCANONE, PERMS, SUMMARY, ...) {
  
  a <- SCANONE %>%
    as_tibble(rownames = "marker")
  
  dist_cM <- a %>%
    select(chr, pos) %>%
    group_by(chr) %>%
    filter(pos == max(pos)) %>%
    ungroup %>%
    mutate(fin = lag(pos),
           space = (5),
           pen = ifelse(is.na(fin), 0, pos + fin + space),
           pen2 = cumsum(pen)) %>%
    select(chr, pen2)
  
  b <- summary(PERMS, ...)
  
  c <- tibble(
    phenotype = b %>% attr("dimnames") %>% .[[2]],
    threshold = b %>% as.numeric() %>% round(., 3)
  )
  
  d <- SUMMARY %>%
    select(phenotype, chr, ci.low, ci.high)
  
  e <- a %>%
    left_join(dist_cM, by = "chr") %>%
    mutate(cM = pos + pen2) %>%
    select(-pen2) %>%
    select(marker:pos, cM, names(.)) %>%
    pivot_longer(
      cols = -c(marker:cM), 
      names_to = "phenotype", 
      values_to = "lod"
    ) %>%
    left_join(c, by = c("phenotype")) %>%
    left_join(d, by = c("chr", "phenotype")) %>%
    mutate(y = pmap_dbl(
      .l = .,
      .f = ~ with( 
        list(...),
        ifelse(dplyr::between(pos, ci.low, ci.high),
               lod,
               NA_real_
               ))))  %>%
    mutate(alpha = ifelse(is.na(y), 0, 1)) %>%
    mutate(chr = as.integer(chr))
  
  breaks <- e %>%
    group_by(chr) %>%
    summarise(breaks = mean(cM))
  
  f <- e %>%
    left_join(breaks, by = "chr")
  
  return(f)
}
# transform MQM results in df to use to plot in ggplot2
mapa_base_MQM <- function(SCANONE, TIBBLE) {
  
  escan <- eval(SCANONE) %>% 
    as_tibble(., rownames = "marker") %>% 
    rename(pos = `pos (cM)`) %>%
    select(-info, - `LOD*info`) %>%
    rename_at(.vars = vars(contains("LOD")), 
              .funs = list(~ gsub("LOD ", "", .)))
  
  
  summ <- TIBBLE %>%
    select(trait, chr, ci.low, ci.high, treshold) %>%
    rename(chr_sum = chr)
  
  mb <- escan %>%
    select(1:3) %>%
    mutate(chr = as.double(chr)) %>%
    group_by(chr) %>%
    nest() %>%
    mutate(max = purrr::map_dbl(.x = data, .f = ~ max(.x$pos))) %>%
    ungroup() %>%
    mutate(comp = lag(cumsum(max)),
           comp2 = (as.numeric(chr)-1)* 25) %>%
    mutate(comp = ifelse(is.na(comp), 0, comp)) %>%
    unnest(data) %>%
    mutate(cM = pos + comp + comp2) %>%
    select(-(max:comp2)) %>%
    group_by(chr) %>% 
    mutate(max = max(cM), 
           min = min(cM), 
           breaks = mean(cM), 
           limit_low = min(cM),
           limit_high= max(cM), 
           inicio = head(cM, n = 1),
           fin = tail(cM, n = 1)) %>% 
    select(marker, chr, cM, pos, (breaks:fin)) %>%
    left_join(., escan %>% select(-chr, -pos)) %>%
    pivot_longer(names_to = "trait", values_to = "lod", cols = -(marker:fin)) %>%
    ungroup()
  
  mb_2 <- mb %>%
    left_join(., summ, by = c("trait" = "trait", "chr" = "chr_sum")) %>%
    mutate(alpha = pmap_dbl(.l = .,
                            .f = ~ case_when(is.na(..12) | is.na(..13) ~ 0,
                                             between(..4, ..12, ..13) ~ 1,
                                             T ~ 0)))
  return(mb_2)
}
# transform MQM results in a tibble
MQM_summary_to_tibble <- function(MQM_perms_df, CROSS, ...) {
  
  mqm_summ <- MQM_perms_df %>% 
    mutate(sum = map2(.x = mqmscan, 
                      .y = perms_2,
                      .f = ~ summary(.x, 
                                     perms = .y, 
                                     alpha = 0.1, 
                                     format = "tabByChr")))
  summary <- mqm_summ %>%
  select(sum, perms_2) %>%
  mutate(treshold = purrr::map_dbl(.x = perms_2, 
                                   .f = ~ summary(object = .x, alpha = 0.1) %>%
                                     as.double(.) %>% 
                                     round(., 2))) %>%
  unnest(sum) %>% 
  filter(!map_lgl(.x = sum, .f = ~ is.null(.x))) %>%  
  mutate(tib = purrr::map(.x =sum, .f = ~ as_tibble(.x, rownames = "trait"))) %>%
  unnest(tib) %>% 
  select(-sum, -perms_2) %>%
  separate(trait, into = c("trait", "marker"), sep = " : ") %>%
  mutate(lodtype = ifelse(grepl("LOD\\*info", trait), "lod*info", "lod")) %>%
  pivot_wider(names_from = lodtype, values_from = lod) %>%
  mutate(`lod*info` = ifelse(is.na(`lod*info`), lead(`lod*info`), `lod*info`)) %>%
  filter(! grepl("LOD\\*info", trait)) %>%
  rename(pos = `pos (cM)`) %>%
  mutate(trait = gsub("LOD ", "", trait),
         marker = pmap_chr(.l = ., 
                           .f = ~ ifelse(!grepl("^(\\d+)\\_", ..3),
                                         find.marker(cross = CROSS, 
                                                     chr = ..4, 
                                                     pos = ..5),
                                         ..2)),
         p_pos = round(as.double(gsub("^(\\d+)\\_", "", marker))/1e6, 2),
         p_pos_l = map2_dbl(.x = chr, .y = ci.low, 
                            .f = ~ find.marker(cross = CROSS,
                                               chr = .x,
                                               pos = .y) %>%
                              gsub("^(\\d+)\\_", "", .) %>% 
                              as.double(.)/1e6) %>% 
           round(.,2),
         p_pos_h = map2_dbl(.x = chr, 
                            .y = ci.high, 
                            .f = ~ find.marker(cross = CROSS,
                                               chr = .x, 
                                               pos = .y) %>%
                              gsub("^(\\d+)\\_", "", .) %>% 
                              as.double(.)/1e6) %>% 
           round(.,2),
         interval = p_pos_h - p_pos_l) %>%
    mutate(chr = as.double(chr)) %>%
    arrange(chr) %>%
    mutate(method = "MQM")
  return(summary)
}
```
Importing data

Data that is goint to be used:

1. Ionomics Data
2. CML312 x W22 HUN mapping population genetic map

```{r}
phenotypes_url <- "https://docs.google.com/spreadsheets/d/1zC8c44uLXKEccDdUKaMmhRGn0JU5wNt1iOYS1xmPWGs/edit#gid=1931442445"

gen_map_url <- "https://docs.google.com/spreadsheets/d/1Abx_s6XxjG91YlLIaFxNn4HNcbnA3lKRgR0jw2DZZek/edit#gid=1187220000"

# Importing lsmeans from the sheets document
ionomics_phenotypes_raw <- phenotypes_url %>%
  as_id %>%
  range_read(., na = "NA") %>%
  select(id = GEN, hun = HUN, matches("seed|leaf"))

#Importing the genetic map of the CML312xW22 HUN F2 mapping population
gen_map <- gen_map_url %>%
  as_id %>%
  range_read(., na = "NA", col_types = "c") 

gen_map <- gen_map %>%
  mutate(id = ifelse(is.na(id), "", id))
```

Transforming data:

- Selecting ionomic phenotypes for leaf and seed
- Declaring color scheme for HUN levels: hun (Non-Pikachu yellow) and wt (green).

```{r}

ionomics_phenotypes <- ionomics_phenotypes_raw %>%
  filter(id != "ARES") %>%
  pivot_longer(-c(id, hun)) %>%
  mutate(name = gsub("\\.SR", "", name)) %>%
  separate(name, into = c("ion", "tissue")) %>%
  filter(!is.na(value))

# Declaring color scheme for hun 
hun_color_scheme <- c("HUN" = "#EDB120", "WT" = "#77AC30")
```

First Look at data.

1. Compare means of HUN and WT families using Kruskal-Wallis non parametric test for every ion and tissue.
2. Make raincloud-plots by ion and tissue, and compare between medians using Kruskal-Wallis non parametric test.

```{r}
create directory for results
dir.create(file.path(getwd(), "output"))
dir.create(file.path(paste0(getwd(), "/output"), "tables"))

# Compare distributions with kruskal-wallis test
ion_tissue_kw <- ionomics_phenotypes %>%
  group_by(ion, tissue) %>%
  nest %>%
  mutate(kw = map(.x = data, 
                  .f = ~ kruskal.test(value ~ hun, 
                                      data = .x))) %>%
  mutate(kw_tidy = map(.x = kw, .f = ~ tidy(.x))) %>%
  ungroup %>%
  select(ion, tissue, kw_tidy) %>%
  unnest(kw_tidy) %>%
  select(ion:p.value) %>%
  mutate(sig = p.value_to_ast(p.value)) %>%
  arrange(ion, tissue)

# save kruskal-wallis test df
write_csv(ion_tissue_kw,
          "output/tables/ion_tissue_kruskal_wallis_test.csv")

# Note: comparison of distributions using kruskal-wallis
ionomics_raincloud_plots <- ionomics_phenotypes %>%
  group_by(ion, tissue) %>%
  mutate(hun = factor(hun, levels = c("WT", "HUN"))) %>%
  nest  %>%
  mutate(plot = map2(.x = data, 
                     .y = tissue,
                     .f = ~ raincloud_plot(data = .x, 
                                           tissue = .y))) %>%
  select(ion, plot) %>%
  group_by(ion) %>%
  summarise(plot = list(plot)) %>% 
  mutate(title = paste0("Ion: ", ion)) %>%
  mutate(wrap = map2(
    .x = plot, 
    .y = title,
    .f = ~ patchwork::wrap_plots(.x, guides = "collect") +
      patchwork::plot_annotation( 
        title = .y,
        theme = theme(plot.title = element_text(hjust = 0.5),
        text = element_text(size=20)
                      )
        )
    )) %>%
  ungroup

p <- ionomics_raincloud_plots$wrap

# # create directory for plots
dir.create(file.path(paste0(getwd(), "/output"), "plots"))
dir.create(file.path(paste0(getwd(), "/output/plots"), "rainclowd_plots"))

# Saving plots into a single pdf
pdf("output/plots/rainclowd_plots/ions_raincloud_plots.pdf",
    onefile = TRUE,
    width = 15, 
    height = 9
    )
walk(p, ~ print(.x))
dev.off()
```

Create CrossObject

1. Create new traits: proportion between leaf/seed values
2. Create CrossObject

```{r}

# ion phenotypes
phenotypes_ion <- ionomics_phenotypes %>%
  mutate(tissue = tolower(tissue)) %>%
  mutate(name = paste0(ion, "_", tissue)) %>%
  select(-c(ion, tissue)) %>%
  pivot_wider(names_from = name, values_from = value)

# ratio between leaf/seed
# phenotypes_ratio <- ionomics_phenotypes %>%
#   mutate(tissue = tolower(tissue)) %>%
#   pivot_wider(names_fro = tissue, values_from = value) %>%
#   mutate(ratio = leaf/seed) %>%
#   select(-c(leaf:seed)) %>%
#   mutate(ion = paste0(ion, "_ratio")) %>%
#   pivot_wider(names_from = ion, values_from = ratio)

# mean between leaf/seed note: standardized using scale function
# phenotypes_mean <- ionomics_phenotypes %>%
#   mutate(tissue = tolower(tissue)) %>%
#   pivot_wider(names_from = tissue, values_from = value) %>%
#   arrange(ion, id) %>%
#   group_by(ion) %>%
#   mutate(across(c(leaf, seed), ~ scale(.))) %>%
#   rowwise() %>%
#   mutate(mn = mean(c(leaf, seed))) %>%
#   select(-c(leaf:seed)) %>%
#   mutate(ion = paste0(ion, "_mean")) %>%
#   pivot_wider(names_from = ion, values_from = mn)

# join all phenotypes
phenotypes_all <- phenotypes_ion %>% 
  select(id, hun, sort(names(.)))

# join all phenotypes with the genetic map and create the CrossObject
crossobject_ion_hun <- gen_map %>%
  mutate(enchar = nchar(id)) %>%
  mutate(id = ifelse(enchar != 6, 
                     gsub("HUN", "HUN0", id),
                     id)) %>%
  select(-enchar) %>%
  filter(id %in% c("", phenotypes_all$id)) %>%
  left_join(phenotypes_all) %>%
  select(all_of(names(phenotypes_all)), names(.)) %>%
  mutate(across(everything(), ~ as.character(.))) %>%
  mutate(across(all_of(names(phenotypes_all)),
                ~ ifelse(is.na(.) & row_number() < 3, "", .)))

# # create directory for the CrossObject
dir.create(file.path(paste0(getwd(), "/output"), "crossobject"))

# save crossobject
write_csv(crossobject_ion_hun,
          "output/crossobject/crossobject_ion_hun.csv")

```
QTL analysis

1. Import CrossObject
2. Create a pheno.col df
3. Identify covariate (genotype on marker 5_2269274)
4. Calculate genoprob and simprob
5. Scanone with an additive covariate model 

```{r}

# Import CrossObject
ion_crossobject <-  read.cross(
  format = "csv",
  dir = "output/crossobject",
  file = "crossobject_ion_hun.csv",
  genotypes = c("AA", "AB", "BB"),
  alleles = c("CML", "W22"),
  BC.gen = 0,
  F.gen = 2,
  estimate.map = F)

# creating a pheno.col dataframe
ion_pheno.col <- ion_crossobject %>%
  phenames %>%
  enframe(name = "pheno.col", value = "phenotype") %>%
  filter(row_number() > 2) 
  
# Identifying covariate (hun genotype)
hun_cov <- pull.geno(ion_crossobject, chr = 5) %>% .[,"5_2269274"]
hun_cov[hun_cov == 3] <- 0

#NOTE: WT = 1; HUN = 0.

# Create directory to save the results

dir.create(file.path(paste0(getwd(), "/output"), "qtl_objects"))
dir.create(file.path(paste0(getwd(), "/output/qtl_objects"), "scanone"))
dir.create(file.path(paste0(getwd(), "/output/qtl_objects"), "permutations"))
dir.create(file.path(paste0(getwd(), "/output/tables"), "scanone_summary"))

# calculate the genetic probabilities
ion_crossobject <- calc.genoprob(
  ion_crossobject, 
  step = 0.5
  )

# simulating genotypes
ion_crossobject <- sim.geno(
  ion_crossobject,
  n.draws = 128, 
  step = 0.5, 
  error.prob = 0.001
  )
```

QTL analysis using scanone without covariates

```{r}
######################################################
# Using scanone applying an additive covariate model #
######################################################

scanone.out.hk <- 
  scanone(ion_crossobject, 
          method = "hk",
          pheno.col = ion_pheno.col$pheno.col, 
          )

# save scanone
save(
  list = c("scanone.out.hk"), 
  file = "output/qtl_objects/scanone/scanone.out.hk.RData"
)

# load("output/qtl_objects/scanone/ion_crossobject_addcov.out.hk.RData")

# Permutation test (1000 permutations)
scanone.operm <- 
  scanone(ion_crossobject, 
          method = "hk",
          pheno.col = ion_pheno.col$pheno.col, 
          n.perm = 1000
          )
# save permutation test
save(
  list = c("scanone.operm"), 
  file = "output/qtl_objects/permutations/scanone.operm.RData"
)

# load("output/qtl_objects/permutations/ion_crossobject_addcov.operm.RData")

# Summary, alpha = 0.05
summary(
  scanone.out.hk,
  perms = scanone.operm, 
  alpha = c(0.1), 
  format= "tabByChr"
  ) 

# transform the summary to tibble
summary_scanone <- summary.to.tibble(
  CROSS = ion_crossobject, 
  SCANONE = scanone.out.hk,
  PERMS = scanone.operm, 
  alpha = 0.1
  )

# Export the summary as a csv
write_csv(
  summary_scanone,
  "output/tables/scanone_summary/summary_scanone.csv"
)

# Create dataframe for lodplots
ion_add_cov_lodplot_df <- lodplot_map_df(
  SCANONE = ion_crossobject_addcov.out.hk,
  SUMMARY = scanone_summary_add_cov,
  PERMS = ion_crossobject_addcov.operm,
  alpha = 0.1,
  ci.funciton = "lodint"
  )

# lodplots for all the phenotypes
ion_add_cov_lodplots_all <- ion_add_cov_lodplot_df %>%
  group_by(phenotype) %>%
  nest %>%
  mutate(
    title = paste0(
      "QTL analysis for additive covariate for ",
      phenotype)) %>%
  mutate(
    plot = map2(
      .x = data, 
      .y = title,
      .f = ~ .x %>% 
        {
        ggplot(
          data =., 
          aes(x = cM, 
              y = lod, 
              group = interaction(chr, alpha)
          )
          ) +
            geom_line(size = 0.75, alpha = 0.3) +
          geom_line(
            aes(alpha = alpha),
            size = 0.75
            ) +
          geom_ribbon(
            aes(ymin = 0, ymax = y), 
            fill = "red", 
            alpha = 0.8
            ) +
          geom_hline( 
            aes(yintercept = unique(threshold)),
            color = "red",
            linetype = 2
            ) +
          scale_alpha_identity() +
          scale_x_continuous(
            name = "chr", 
            breaks = unique(.$breaks), 
            labels = unique(as.character((.$chr)))
            ) +
            theme(
              panel.background = 
                element_rect(
                fill = "white",
                colour = "grey50")) +
            ggtitle(.y)
      }
    )
  ) 

# # create directory for plots
# dir.create(file.path(paste0(getwd(), "/output/plots"),
#                      "scanone_lodplots"))
p <- ion_add_cov_lodplots_all$plot

# Saving plots into a single pdf
ggsave(
   filename = 
     "output/plots/scanone_lodplots/ion_add_cov_lodplots_all.pdf", 
   plot = gridExtra::marrangeGrob(p, nrow=1, ncol=1), 
   width = 15, height = 9
)

# Only significant plots
ion_add_cov_lodplots_signif <- ion_add_cov_lodplots_all %>%
  semi_join(scanone_summary_add_cov)

p <- ion_add_cov_lodplots_signif$plot

# Saving plots into a single pdf
ggsave(
   filename = 
     "output/plots/scanone_lodplots/ion_add_cov_lodplots_signif.pdf", 
   plot = gridExtra::marrangeGrob(p, nrow=1, ncol=1), 
   width = 15, height = 9
)

# all significant plots in the same page
ion_add_cov_lodplots_signif_single <- ion_add_cov_lodplots_signif %>%
  select(phenotype, data) %>%
  unnest(data) %>% {
    ggplot(data =., 
           aes(x = cM, y = lod, group = interaction(chr, alpha))) +
      geom_line(size = 0.75, alpha = 0.3) +
      geom_line(aes(alpha = alpha), size = 0.75) +
      geom_ribbon(aes(ymin = 0, ymax = y), fill = "red", alpha = 0.8 ) +
      geom_hline(aes(yintercept = threshold), color = "red",
                 linetype = 2) +
      scale_alpha_identity() +
      scale_x_continuous(name = "chr", 
                         breaks = unique(.$breaks),
                         labels = unique(as.character((.$chr)))) +
  theme(panel.background = element_rect( fill = "white",
                                         colour = "grey50")) +
  ggtitle("QTL analysis sig peaks additive covariate") +
  facet_grid(phenotype ~ .)
      }

ggsave(
   filename =
     "output/plots/scanone_lodplots/ion_add_cov_lodplots_signif_single.pdf", 
   plot = ion_add_cov_lodplots_signif_single, 
   width = 15, 
   height = 18
)
```

QTL analysis with an additive covariate model
```{r}

######################################################
# Using scanone applying an additive covariate model #
######################################################

scanone.addcov.out.hk <- 
  scanone(ion_crossobject, 
          method = "hk",
          pheno.col = ion_pheno.col$pheno.col, 
          addcovar = hun_cov
          )

# save scanone
save(
  list = c("scanone.addcov.out.hk"), 
  file = "output/qtl_objects/scanone/scanone.addcov.out.hk.RData"
)

# load("output/qtl_objects/scanone/ion_crossobject_addcov.out.hk.RData")

# Permutation test (1000 permutations)
scanone.addcov.operm <- 
  scanone(ion_crossobject, 
          method = "hk",
          pheno.col = ion_pheno.col$pheno.col, 
          addcovar = hun_cov,
          n.perm = 1000
          )
# save permutation test
save(
  list = c("scanone.addcov.operm"), 
  file = "output/qtl_objects/permutations/scanone.addcov.operm.RData"
)

load("output/qtl_objects/permutations/ion_crossobject_addcov.operm.RData")

# Summary, alpha = 0.05
summary(
  scanone.addcov.out.hk,
  perms = scanone.addcov.operm, alpha = c(0.05), 
  format= "tabByChr"
  ) 

# transform the summary to tibble
summary_scanone.addcov <- summary.to.tibble(
  CROSS = ion_crossobject, 
  SCANONE = scanone.addcov.out.hk,
  PERMS = scanone.addcov.operm, 
  alpha = 0.1
  )

# Export the summary as a csv
write_csv(
  summary_scanone.addcov,
  "output/tables/scanone_summary/summary_scanone.addcov.csv"
)

# Create dataframe for lodplots
ion_add_cov_lodplot_df <- lodplot_map_df(
  SCANONE = ion_crossobject_addcov.out.hk,
  SUMMARY = scanone_summary_add_cov,
  PERMS = ion_crossobject_addcov.operm,
  alpha = 0.1,
  ci.funciton = "lodint"
  )

# lodplots for all the phenotypes
ion_add_cov_lodplots_all <- ion_add_cov_lodplot_df %>%
  group_by(phenotype) %>%
  nest %>%
  mutate(
    title = paste0(
      "QTL analysis for additive covariate for ",
      phenotype)) %>%
  mutate(
    plot = map2(
      .x = data, 
      .y = title,
      .f = ~ .x %>% 
        {
        ggplot(
          data =., 
          aes(x = cM, 
              y = lod, 
              group = interaction(chr, alpha)
          )
          ) +
            geom_line(size = 0.75, alpha = 0.3) +
          geom_line(
            aes(alpha = alpha),
            size = 0.75
            ) +
          geom_ribbon(
            aes(ymin = 0, ymax = y), 
            fill = "red", 
            alpha = 0.8
            ) +
          geom_hline( 
            aes(yintercept = unique(threshold)),
            color = "red",
            linetype = 2
            ) +
          scale_alpha_identity() +
          scale_x_continuous(
            name = "chr", 
            breaks = unique(.$breaks), 
            labels = unique(as.character((.$chr)))
            ) +
            theme(
              panel.background = 
                element_rect(
                fill = "white",
                colour = "grey50")) +
            ggtitle(.y)
      }
    )
  ) 

# # create directory for plots
# dir.create(file.path(paste0(getwd(), "/output/plots"),
#                      "scanone_lodplots"))
p <- ion_add_cov_lodplots_all$plot

# Saving plots into a single pdf
ggsave(
   filename = 
     "output/plots/scanone_lodplots/ion_add_cov_lodplots_all.pdf", 
   plot = gridExtra::marrangeGrob(p, nrow=1, ncol=1), 
   width = 15, height = 9
)

# Only significant plots
ion_add_cov_lodplots_signif <- ion_add_cov_lodplots_all %>%
  semi_join(scanone_summary_add_cov)

p <- ion_add_cov_lodplots_signif$plot

# Saving plots into a single pdf
ggsave(
   filename = 
     "output/plots/scanone_lodplots/ion_add_cov_lodplots_signif.pdf", 
   plot = gridExtra::marrangeGrob(p, nrow=1, ncol=1), 
   width = 15, height = 9
)

# all significant plots in the same page
ion_add_cov_lodplots_signif_single <- ion_add_cov_lodplots_signif %>%
  select(phenotype, data) %>%
  unnest(data) %>% {
    ggplot(data =., 
           aes(x = cM, y = lod, group = interaction(chr, alpha))) +
      geom_line(size = 0.75, alpha = 0.3) +
      geom_line(aes(alpha = alpha), size = 0.75) +
      geom_ribbon(aes(ymin = 0, ymax = y), fill = "red", alpha = 0.8 ) +
      geom_hline(aes(yintercept = threshold), color = "red",
                 linetype = 2) +
      scale_alpha_identity() +
      scale_x_continuous(name = "chr", 
                         breaks = unique(.$breaks),
                         labels = unique(as.character((.$chr)))) +
  theme(panel.background = element_rect( fill = "white",
                                         colour = "grey50")) +
  ggtitle("QTL analysis sig peaks additive covariate") +
  facet_grid(phenotype ~ .)
      }

ggsave(
   filename =
     "output/plots/scanone_lodplots/ion_add_cov_lodplots_signif_single.pdf", 
   plot = ion_add_cov_lodplots_signif_single, 
   width = 15, 
   height = 18
)
```

Assessing the evidence of additive effect of the covariate

```{r}
# Comparing models and looking for evidence for the effect of hun as an additive covariate

# scanone
scanone.addboth.out.hk <- c(
  scanone.out.hk,
  scanone.addcov.out.hk,
  labels = c("nocovar", "covar")
)

# save scanone
save(
  list = c("scanone.addboth.out.hk"), 
  file = "output/qtl_objects/scanone/scanone.addboth.out.hk.RData"
)

# permutations
scanone.addboth.operm <- cbind(
  scanone.operm,
  scanone.addcov.operm,
  labels = c("nocovar", "covar")
)

# save permutation test
save(
  list = c("scanone.addboth.operm"), 
  file = "output/qtl_objects/permutations/scanone.addboth.operm.RData"
)

# load("output/qtl_objects/permutations/ion_int_add.operm.RData")

# Summary
summary(
  scanone.addboth.out.hk, 
  perms = scanone.addboth.operm, 
  alpha = c(0.05), 
  format = "tabByChr"
  )

# transform the summary to tibble
summary_scanone.addcov.both <- summary.to.tibble(
  CROSS = ion_crossobject, 
  SCANONE = scanone.addboth.out.hk,
  PERMS = scanone.addboth.operm, 
  alpha = 0.1
  )

# Export the summary as a csv
write_csv(
  scanone_summary_int_add_cov,
  "output/tables/scanone_summary/summary_scanone.addcov.both.csv"
)

ions_interesting_qtl_addint <- scanone_summary_int_add_cov %>%
  arrange(phenotype) %>%
  separate(phenotype, into = c("phenotype2", "model"), sep = "\\.",
           remove = F) %>%
  group_by(phenotype2, chr) %>%
  filter(dplyr::n() != 1)

# Create dataframe for lodplots
ion_int_add_cov_lodplot_df <- lodplot_map_df(
  SCANONE = ion_int_add.out.hk,
  SUMMARY = scanone_summary_int_add_cov,
  PERMS = ion_int_add.operm,
  alpha = 0.1,
  ci.funciton = "lodint"
  )

# lodplots for all the phenotypes
ion_int_add_cov_lodplots_all <- ion_int_add_cov_lodplot_df %>%
  group_by(phenotype) %>%
  nest %>%
  arrange(phenotype) %>%
  mutate(
    title = paste0(
      "QTL analysis for int_additive covariate for ",
      phenotype)) %>%
  mutate(
    plot = map2(
      .x = data, 
      .y = title,
      .f = ~ .x %>% 
        {
        ggplot(
          data =., 
          aes(x = cM, 
              y = lod, 
              group = interaction(chr, alpha)
          )
          ) +
            geom_line(size = 0.75, alpha = 0.3) +
          geom_line(
            aes(alpha = alpha),
            size = 0.75
            ) +
          geom_ribbon(
            aes(ymin = 0, ymax = y), 
            fill = "red", 
            alpha = 0.8
            ) +
          geom_hline( 
            aes(yintercept = unique(threshold)),
            color = "red",
            linetype = 2
            ) +
          scale_alpha_identity() +
          scale_x_continuous(
            name = "chr", 
            breaks = unique(.$breaks), 
            labels = unique(as.character((.$chr)))
            ) +
            theme(
              panel.background = 
                element_rect(
                fill = "white",
                colour = "grey50")) +
            ggtitle(.y)
      }
    )
  ) 


p <- ion_int_add_cov_lodplots_all$plot

# Saving plots int_addo a single pdf
ggsave(
   filename = 
     "output/plots/scanone_lodplots/ion_int_add_cov_lodplots_all.pdf", 
   plot = gridExtra::marrangeGrob(p, nrow=1, ncol=1), 
   width = 15, height = 9
)

# Only significant plots
ion_int_add_cov_lodplots_signif <- ion_int_add_cov_lodplots_all %>%
  semi_join(scanone_summary_int_add_cov)

p <- ion_int_add_cov_lodplots_signif$plot

# Saving plots int_addo a single pdf
ggsave(
   filename = 
     "output/plots/scanone_lodplots/ion_int_add_cov_lodplots_signif.pdf", 
   plot = gridExtra::marrangeGrob(p, nrow=1, ncol=1), 
   width = 15, height = 9
)


# all significant plots in the same page

ion_int_add_cov_lodplots_interesting <- ion_int_add_cov_lodplots_all %>%
  semi_join(ions_interesting_qtl_addint) %>%
  select(phenotype, data) %>%
  unnest(data) %>% {
    ggplot(data =., 
           aes(x = cM, y = lod, group = interaction(chr, alpha))) +
      geom_line(size = 0.75, alpha = 0.3) +
      geom_line(aes(alpha = alpha), size = 0.75) +
      geom_ribbon(aes(ymin = 0, ymax = y), fill = "red", alpha = 0.8 ) +
      geom_hline(aes(yintercept = threshold), color = "red",
                 linetype = 2) +
      scale_alpha_identity() +
      scale_x_continuous(name = "chr", 
                         breaks = unique(.$breaks),
                         labels = unique(as.character((.$chr)))) +
  theme(panel.background = element_rect( fill = "white",
                                         colour = "grey50")) +
  ggtitle("QTL analysis sig peaks int_additive covariate") +
  facet_grid(phenotype ~ .)
      }

ggsave(
   filename =
     "output/plots/scanone_lodplots/ion_int_add_cov_lodplots_interesting.pdf", 
   plot = ion_int_add_cov_lodplots_interesting, 
   width = 15, 
   height = 18
)


```

QTL analysis with an interactive covariate model

```{r}
##################################################
# Using scanone aplying an interactive covariate #
##################################################

scanone.intcov.out.hk <- 
  scanone(ion_crossobject, 
          method = "hk",
          pheno.col = ion_pheno.col$pheno.col, 
          addcovar = hun_cov,
          intcovar = hun_cov
          )

# save scanone
save(
  list = c("scanone.intcov.out.hk"), 
  file = "output/qtl_objects/scanone/scanone.intcov.out.hk.RData"
)

# load("output/qtl_objects/scanone/ion_crossobject_intcov.out.hk.RData")
# Permutation test
scanone.intcov.operm <- 
  scanone(ion_crossobject, 
          method = "hk",
          pheno.col = ion_pheno.col$pheno.col, 
          addcovar = hun_cov,
          intcovar = hun_cov,
          n.perm = 1000
          )

# save permutation test
save(
  list = c("ion_crossobject_intcov.operm"), 
  file = "output/qtl_objects/permutations/ion_crossobject_intcov.operm.RData"
)

load("output/qtl_objects/permutations/ion_crossobject_intcov.operm.RData")

# Summary 
summary(
  ion_crossobject_intcov.out.hk, 
  perms = ion_crossobject_intcov.operm, 
  alpha = c(0.1), 
  format= "tabByChr"
  )

# transform the summary to tibble
scanone_summary_int_cov <- summary.to.tibble(
  CROSS = ion_crossobject, 
  SCANONE = ion_crossobject_intcov.out.hk,
  PERMS = ion_crossobject_intcov.operm, 
  alpha = 0.1
  )

# Export the summary as a csv
write_csv(
  scanone_summary_int_cov,
  "output/tables/scanone_summary/scanone_summary_int_cov.csv"
)

# Create dataframe for lodplots
ion_int_cov_lodplot_df <- lodplot_map_df(
  SCANONE = ion_crossobject_intcov.out.hk,
  SUMMARY = scanone_summary_int_cov,
  PERMS = ion_crossobject_intcov.operm,
  alpha = 0.1,
  ci.funciton = "lodint"
  )

# lodplots for all the phenotypes
ion_int_cov_lodplots_all <- ion_int_cov_lodplot_df %>%
  group_by(phenotype) %>%
  nest %>%
  mutate(
    title = paste0(
      "QTL analysis for intitive covariate for ",
      phenotype)) %>%
  mutate(
    plot = map2(
      .x = data, 
      .y = title,
      .f = ~ .x %>% 
        {
        ggplot(
          data =., 
          aes(x = cM, 
              y = lod, 
              group = interaction(chr, alpha)
          )
          ) +
            geom_line(size = 0.75, alpha = 0.3) +
          geom_line(
            aes(alpha = alpha),
            size = 0.75
            ) +
          geom_ribbon(
            aes(ymin = 0, ymax = y), 
            fill = "red", 
            alpha = 0.8
            ) +
          geom_hline( 
            aes(yintercept = unique(threshold)),
            color = "red",
            linetype = 2
            ) +
          scale_alpha_identity() +
          scale_x_continuous(
            name = "chr", 
            breaks = unique(.$breaks), 
            labels = unique(as.character((.$chr)))
            ) +
            theme(
              panel.background = 
                element_rect(
                fill = "white",
                colour = "grey50")) +
            ggtitle(.y)
      }
    )
  ) 

# create directory for plots
dir.create(file.path(paste0(getwd(), "/output/plots"),
                     "scanone_lodplots"))
p <- ion_int_cov_lodplots_all$plot

# Saving plots into a single pdf
ggsave(
   filename = 
     "output/plots/scanone_lodplots/ion_int_cov_lodplots_all.pdf", 
   plot = gridExtra::marrangeGrob(p, nrow=1, ncol=1), 
   width = 15, height = 9
)

# Only significant plots
ion_int_cov_lodplots_signif <- ion_int_cov_lodplots_all %>%
  semi_join(scanone_summary_int_cov)

p <- ion_int_cov_lodplots_signif$plot

# Saving plots into a single pdf
ggsave(
   filename = 
     "output/plots/scanone_lodplots/ion_int_cov_lodplots_signif.pdf", 
   plot = gridExtra::marrangeGrob(p, nrow=1, ncol=1), 
   width = 15, height = 9
)

# all significant plots in the same page
ion_int_cov_lodplots_signif_single <- ion_int_cov_lodplots_signif %>%
  select(phenotype, data) %>%
  unnest(data) %>% {
    ggplot(data =., 
           aes(x = cM, y = lod, group = interaction(chr, alpha))) +
      geom_line(size = 0.75, alpha = 0.3) +
      geom_line(aes(alpha = alpha), size = 0.75) +
      geom_ribbon(aes(ymin = 0, ymax = y), fill = "red", alpha = 0.8 ) +
      geom_hline(aes(yintercept = threshold), color = "red",
                 linetype = 2) +
      scale_alpha_identity() +
      scale_x_continuous(name = "chr", 
                         breaks = unique(.$breaks),
                         labels = unique(as.character((.$chr)))) +
  theme(panel.background = element_rect( fill = "white",
                                         colour = "grey50")) +
  ggtitle("QTL analysis sig peaks intitive covariate") +
  facet_grid(phenotype ~ .)
      }

ggsave(
   filename =
     "output/plots/scanone_lodplots/ion_int_cov_lodplots_signif_single.pdf", 
   plot = ion_int_cov_lodplots_signif_single, 
   width = 15, 
   height = 18
)
```

```{r}
