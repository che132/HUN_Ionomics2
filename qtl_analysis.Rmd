---
title: "qtl_analysis"
author: "SERGIO PEREZ-LIMON"
date: "7/21/2021"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Load libraries, set seed and set working directory

```{r}
library(tidyverse)
library(googlesheets4)
library(googledrive)
library(qtl)
library(broom)
library(pals)
library(patchwork)

# Set the seed as the same value as previous analysis
set.seed(54955149)

# Note: don't forget to set working directory the same as project directory
```

Functions

```{r}

# transform p.value to significance codes
p.value_to_ast <- function(p.value) {
  
  ast <- case_when(
    p.value < 0.001 ~ "***",
    p.value >= 0.001 & p.value < 0.01 ~ "**",
    p.value >= 0.01 & p.value < 0.05 ~ "*",
    p.value >= 0.05 & p.value < 0.01 ~ ".",
    p.value > 0.01 ~ "NS",
    T ~ NA_character_)
  
  return(ast)
  
}
# raincloud plots function
raincloud_plot <- function(data, tissue) {
  
  plot <- data %>%
    ggplot(data =., 
           aes(x = hun, 
               y = value, 
               fill = hun)
           ) +
    ggdist::stat_halfeye(aes(fill = hun),
                         adjust = .5, 
                         width = .6, 
                         .width = 0, 
                         justification = -.2, 
                         point_colour = NA,
                         color = "black",
                         ) +
    geom_boxplot(
      width = .15, 
      outlier.shape = NA,
      color = "black"
      ) +
    gghalves::geom_half_point(
      ## draw jitter on the left
      side = "l", 
      ## control range of jitter
      range_scale = .4, 
      ## add some transparency
      alpha = .5,
      shape = 21,
      color = "black"
      ) +
    ggpubr::stat_compare_means(
      comparisons = list(c("HUN", "WT")),
      label = "p.signif",
      method = "wilcox.test") +
    xlab(NULL) +
    ylab("ppm") +
    theme(
      panel.background = element_rect(fill = "white", 
                                      colour ="grey50"),
      plot.title = element_text(hjust = 0.5),
      text = element_text(size=20)
      ) +
    scale_fill_manual(
      values = hun_color_scheme, guide = NULL
      ) +
    ggtitle(tissue)
  
  return(plot)
}
# transform summary and add information in a suitable tibble
summary.to.tibble <- function(CROSS, SCANONE, PERMS, ...) {
  
  a <- summary(
    object = SCANONE, 
    perms = PERMS,
    format = "tabByChr",
    ci.function = "bayesint",
    prob = 0.9,
    ...
  ) 
  
  
  b <- summary(PERMS, ...)
  
  c <- tibble(
    phenotype = b %>% attr("dimnames") %>% .[[2]],
    threshold = b %>% as.numeric() %>% round(., 3)
  )
  
  p1 <- a %>%
    map_df(
      .x = ., 
      .f = ~ as_tibble(.x, rownames = "qtl"), 
      .id = "chr"
    ) %>%
    separate(
      qtl, 
      into = c("phenotype", "marker"), 
      sep = " : "
    ) %>%
    arrange(chr, pos, phenotype) %>%
    mutate(
      marker = map2_chr(
        .x = chr,
        .y = pos,
        .f = ~ find.marker(cross = CROSS,
                           chr = .x,
                           pos = .y)))
  
  p2 <- p1 %>%
    pivot_longer(c(pos, ci.low, ci.high)) %>%
    mutate(
      c_marker = map2_chr(
        .x = chr,
        .y = value,
        .f = ~ find.marker(
          cross = CROSS,       
          chr = .x,
          pos = .y
        )
      )) %>%
    mutate(c_marker = gsub("^\\d{1,}_", "", c_marker) %>% as.integer,
           c_marker = round(c_marker/1e6, 3),
           name = paste0("p_", name)) %>%
    select(-value) %>%
    pivot_wider(names_from = name, values_from = c_marker) %>%
    mutate(interval = p_ci.high - p_ci.low)
  
  p3 <- p1 %>%
    left_join(p2, by = c("phenotype", "marker", "chr", "lod")) %>%
    left_join(c, by = "phenotype")
  
  
  return(p3)
}
# transform results in df to use to plot in ggplot2
lodplot_map_df <- function(SCANONE, PERMS, SUMMARY, ...) {
  
  a <- SCANONE %>%
    as_tibble(rownames = "marker")
  
  dist_cM <- a %>%
    select(chr, pos) %>%
    group_by(chr) %>%
    filter(pos == max(pos)) %>%
    ungroup %>%
    mutate(fin = lag(pos),
           space = (5),
           pen = ifelse(is.na(fin), 0, pos + fin + space),
           pen2 = cumsum(pen)) %>%
    select(chr, pen2)
  
  b <- summary(PERMS, ...)
  
  c <- tibble(
    phenotype = b %>% attr("dimnames") %>% .[[2]],
    threshold = b %>% as.numeric() %>% round(., 3)
  )
  
  d <- SUMMARY %>%
    select(phenotype, chr, ci.low, ci.high)
  
  e <- a %>%
    left_join(dist_cM, by = "chr") %>%
    mutate(cM = pos + pen2) %>%
    select(-pen2) %>%
    select(marker:pos, cM, names(.)) %>%
    pivot_longer(
      cols = -c(marker:cM), 
      names_to = "phenotype", 
      values_to = "lod"
    ) %>%
    left_join(c, by = c("phenotype")) %>%
    left_join(d, by = c("chr", "phenotype")) %>%
    mutate(y = pmap_dbl(
      .l = .,
      .f = ~ with( 
        list(...),
        ifelse(dplyr::between(pos, ci.low, ci.high),
               lod,
               NA_real_
               ))))  %>%
    mutate(alpha = ifelse(is.na(y), 0, 1)) %>%
    mutate(chr = as.integer(chr))
  
  breaks <- e %>%
    group_by(chr) %>%
    summarise(breaks = mean(cM))
  
  f <- e %>%
    left_join(breaks, by = "chr")
  
  return(f)
}
# transform MQM results in df to use to plot in ggplot2
mapa_base_MQM <- function(SCANONE, TIBBLE) {
  
  escan <- eval(SCANONE) %>% 
    as_tibble(., rownames = "marker") %>% 
    rename(pos = `pos (cM)`) %>%
    select(-info, - `LOD*info`) %>%
    rename_at(.vars = vars(contains("LOD")), 
              .funs = list(~ gsub("LOD ", "", .)))
  
  
  summ <- TIBBLE %>%
    select(trait, chr, ci.low, ci.high, treshold) %>%
    rename(chr_sum = chr)
  
  mb <- escan %>%
    select(1:3) %>%
    mutate(chr = as.double(chr)) %>%
    group_by(chr) %>%
    nest() %>%
    mutate(max = purrr::map_dbl(.x = data, .f = ~ max(.x$pos))) %>%
    ungroup() %>%
    mutate(comp = lag(cumsum(max)),
           comp2 = (as.numeric(chr)-1)* 25) %>%
    mutate(comp = ifelse(is.na(comp), 0, comp)) %>%
    unnest(data) %>%
    mutate(cM = pos + comp + comp2) %>%
    select(-(max:comp2)) %>%
    group_by(chr) %>% 
    mutate(max = max(cM), 
           min = min(cM), 
           breaks = mean(cM), 
           limit_low = min(cM),
           limit_high= max(cM), 
           inicio = head(cM, n = 1),
           fin = tail(cM, n = 1)) %>% 
    select(marker, chr, cM, pos, (breaks:fin)) %>%
    left_join(., escan %>% select(-chr, -pos)) %>%
    pivot_longer(names_to = "trait", values_to = "lod", cols = -(marker:fin)) %>%
    ungroup()
  
  mb_2 <- mb %>%
    left_join(., summ, by = c("trait" = "trait", "chr" = "chr_sum")) %>%
    mutate(alpha = pmap_dbl(.l = .,
                            .f = ~ case_when(is.na(..12) | is.na(..13) ~ 0,
                                             between(..4, ..12, ..13) ~ 1,
                                             T ~ 0)))
  return(mb_2)
}
# transform MQM results in a tibble
MQM_summary_to_tibble <- function(MQM_perms_df, CROSS, ...) {
  
  mqm_summ <- MQM_perms_df %>% 
    mutate(sum = map2(.x = mqmscan, 
                      .y = perms_2,
                      .f = ~ summary(.x, 
                                     perms = .y, 
                                     alpha = 0.1, 
                                     format = "tabByChr")))
  summary <- mqm_summ %>%
  select(sum, perms_2) %>%
  mutate(treshold = purrr::map_dbl(.x = perms_2, 
                                   .f = ~ summary(object = .x, alpha = 0.1) %>%
                                     as.double(.) %>% 
                                     round(., 2))) %>%
  unnest(sum) %>% 
  filter(!map_lgl(.x = sum, .f = ~ is.null(.x))) %>%  
  mutate(tib = purrr::map(.x =sum, .f = ~ as_tibble(.x, rownames = "trait"))) %>%
  unnest(tib) %>% 
  select(-sum, -perms_2) %>%
  separate(trait, into = c("trait", "marker"), sep = " : ") %>%
  mutate(lodtype = ifelse(grepl("LOD\\*info", trait), "lod*info", "lod")) %>%
  pivot_wider(names_from = lodtype, values_from = lod) %>%
  mutate(`lod*info` = ifelse(is.na(`lod*info`), lead(`lod*info`), `lod*info`)) %>%
  filter(! grepl("LOD\\*info", trait)) %>%
  rename(pos = `pos (cM)`) %>%
  mutate(trait = gsub("LOD ", "", trait),
         marker = pmap_chr(.l = ., 
                           .f = ~ ifelse(!grepl("^(\\d+)\\_", ..3),
                                         find.marker(cross = CROSS, 
                                                     chr = ..4, 
                                                     pos = ..5),
                                         ..2)),
         p_pos = round(as.double(gsub("^(\\d+)\\_", "", marker))/1e6, 2),
         p_pos_l = map2_dbl(.x = chr, .y = ci.low, 
                            .f = ~ find.marker(cross = CROSS,
                                               chr = .x,
                                               pos = .y) %>%
                              gsub("^(\\d+)\\_", "", .) %>% 
                              as.double(.)/1e6) %>% 
           round(.,2),
         p_pos_h = map2_dbl(.x = chr, 
                            .y = ci.high, 
                            .f = ~ find.marker(cross = CROSS,
                                               chr = .x, 
                                               pos = .y) %>%
                              gsub("^(\\d+)\\_", "", .) %>% 
                              as.double(.)/1e6) %>% 
           round(.,2),
         interval = p_pos_h - p_pos_l) %>%
    mutate(chr = as.double(chr)) %>%
    arrange(chr) %>%
    mutate(method = "MQM")
  return(summary)
}
```
Importing data

Data that is goint to be used:

1. Ionomics Data
2. CML312 x W22 HUN mapping population genetic map
```{r}
phenotypes_url <- "https://docs.google.com/spreadsheets/d/1zC8c44uLXKEccDdUKaMmhRGn0JU5wNt1iOYS1xmPWGs/edit#gid=1931442445"

gen_map_url <- "https://docs.google.com/spreadsheets/d/1Abx_s6XxjG91YlLIaFxNn4HNcbnA3lKRgR0jw2DZZek/edit#gid=1187220000"

phenotypes_all_url <- "https://docs.google.com/spreadsheets/d/1agklzlH0HWUT5Axyf-yTKsuk88F--Mt0dLB4xAZqXIM/edit#gid=1931442445"

# Importing lsmeans from the sheets document
ionomics_phenotypes_raw <- phenotypes_url %>%
  as_id %>%
  range_read(., na = "NA") %>%
  select(id = GEN, hun = HUN, matches("seed|leaf"))

#Importing the genetic map of the CML312xW22 HUN F2 mapping population
gen_map <- gen_map_url %>%
  as_id %>%
  range_read(., na = "NA", col_types = "c") 

gen_map <- gen_map %>%
  mutate(id = ifelse(is.na(id), "", id))

ionomics_phenotypes_raw_non_ion <- phenotypes_all_url %>%
  as_id %>%
  range_read(., na = "NA") %>%
  rename(id = GEN, hun = HUN)


```
Transforming data:

- Selecting ionomic phenotypes for leaf and seed
- Declaring color scheme for HUN levels: hun (Non-Pikachu yellow) and wt (green).
```{r}

ionomics_phenotypes <- ionomics_phenotypes_raw_all %>%
  filter(id != "ARES") %>%
  pivot_longer(-c(id, hun)) %>%
  mutate(name = gsub("\\.SR", "", name)) %>%
  separate(name, into = c("ion", "tissue")) %>%
  filter(!is.na(value))

# Declaring color scheme for hun 
hun_color_scheme <- c("HUN" = "#EDB120", "WT" = "#77AC30")
```
First Look at data.

1. Compare means of HUN and WT families using Kruskal-Wallis non parametric test for every ion and tissue.
2. Make raincloud-plots by ion and tissue, and compare between medians using Kruskal-Wallis non parametric test.
```{r}
# create directory for results
dir.create(file.path(getwd(), "output"))
dir.create(file.path(paste0(getwd(), "/output"), "tables"))

# Compare distributions with kruskal-wallis test
ion_tissue_kw <- ionomics_phenotypes %>%
  group_by(ion, tissue) %>%
  nest %>%
  mutate(kw = map(.x = data, 
                  .f = ~ kruskal.test(value ~ hun, 
                                      data = .x))) %>%
  mutate(kw_tidy = map(.x = kw, .f = ~ tidy(.x))) %>%
  ungroup %>%
  select(ion, tissue, kw_tidy) %>%
  unnest(kw_tidy) %>%
  select(ion:p.value) %>%
  mutate(sig = p.value_to_ast(p.value)) %>%
  arrange(ion, tissue)

# save kruskal-wallis test df
write_csv(ion_tissue_kw,
          "output/tables/ion_tissue_kruskal_wallis_test.csv")

# Note: comparison of distributions using kruskal-wallis
ionomics_raincloud_plots <- ionomics_phenotypes %>%
  group_by(ion, tissue) %>%
  mutate(hun = factor(hun, levels = c("WT", "HUN"))) %>%
  nest  %>%
  mutate(plot = map2(.x = data, 
                     .y = tissue,
                     .f = ~ raincloud_plot(data = .x, 
                                           tissue = .y))) %>%
  select(ion, plot) %>%
  group_by(ion) %>%
  summarise(plot = list(plot)) %>% 
  mutate(title = paste0("Ion: ", ion)) %>%
  mutate(wrap = map2(
    .x = plot, 
    .y = title,
    .f = ~ patchwork::wrap_plots(.x, guides = "collect") +
      patchwork::plot_annotation( 
        title = .y,
        theme = theme(plot.title = element_text(hjust = 0.5),
        text = element_text(size=20)
                      )
        )
    )) %>%
  ungroup

p <- ionomics_raincloud_plots$wrap

# # create directory for plots
dir.create(file.path(paste0(getwd(), "/output"), "plots"))
dir.create(file.path(paste0(getwd(), "/output/plots"), "rainclowd_plots"))

# Saving plots into a single pdf
pdf("output/plots/rainclowd_plots/ions_raincloud_plots.pdf",
    onefile = TRUE,
    width = 15, 
    height = 9
    )
walk(p, ~ print(.x))
dev.off()
```
Create CrossObject

1. Create new traits: proportion between leaf/seed values
2. Create CrossObject
```{r}

# ion phenotypes
phenotypes_ion <- ionomics_phenotypes %>%
  mutate(tissue = tolower(tissue)) %>%
  mutate(name = paste0(ion, "_", tissue)) %>%
  select(-c(ion, tissue)) %>%
  pivot_wider(names_from = name, values_from = value)

# ratio between leaf/seed
# phenotypes_ratio <- ionomics_phenotypes %>%
#   mutate(tissue = tolower(tissue)) %>%
#   pivot_wider(names_fro = tissue, values_from = value) %>%
#   mutate(ratio = leaf/seed) %>%
#   select(-c(leaf:seed)) %>%
#   mutate(ion = paste0(ion, "_ratio")) %>%
#   pivot_wider(names_from = ion, values_from = ratio)

# mean between leaf/seed note: standardized using scale function
# phenotypes_mean <- ionomics_phenotypes %>%
#   mutate(tissue = tolower(tissue)) %>%
#   pivot_wider(names_from = tissue, values_from = value) %>%
#   arrange(ion, id) %>%
#   group_by(ion) %>%
#   mutate(across(c(leaf, seed), ~ scale(.))) %>%
#   rowwise() %>%
#   mutate(mn = mean(c(leaf, seed))) %>%
#   select(-c(leaf:seed)) %>%
#   mutate(ion = paste0(ion, "_mean")) %>%
#   pivot_wider(names_from = ion, values_from = mn)

# join all phenotypes
phenotypes_all <- phenotypes_ion %>% 
  select(id, hun, sort(names(.)))

# join all phenotypes with the genetic map and create the CrossObject
crossobject_ion_hun <- gen_map %>%
  mutate(enchar = nchar(id)) %>%
  mutate(id = ifelse(enchar != 6, 
                     gsub("HUN", "HUN0", id),
                     id)) %>%
  select(-enchar) %>%
  filter(id %in% c("", phenotypes_all$id)) %>%
  left_join(phenotypes_all) %>%
  select(all_of(names(phenotypes_all)), names(.)) %>%
  mutate(across(everything(), ~ as.character(.))) %>%
  mutate(across(all_of(names(phenotypes_all)),
                ~ ifelse(is.na(.) & row_number() < 3, "", .)))

# # create directory for the CrossObject
dir.create(file.path(paste0(getwd(), "/output"), "crossobject"))

# save crossobject
write_csv(crossobject_ion_hun,
          "output/crossobject/crossobject_ion_hun.csv")

```
QTL analysis

1. Import CrossObject
2. Create a pheno.col df
3. Identify covariate (genotype on marker 5_2269274)
4. Calculate genoprob and simprob
5. Scanone with an additive covariate model 
```{r}

# Import CrossObject
ion_crossobject <-  read.cross(
  format = "csv",
  dir = "output/crossobject",
  file = "crossobject_ion_hun.csv",
  genotypes = c("AA", "AB", "BB"),
  alleles = c("CML", "W22"),
  BC.gen = 0,
  F.gen = 2,
  estimate.map = F)

# creating a pheno.col dataframe
ion_pheno.col <- ion_crossobject %>%
  phenames %>%
  enframe(name = "pheno.col", value = "phenotype") %>%
  filter(row_number() > 2) 
  
# Identifying covariate (hun genotype)
hun_cov <- pull.geno(ion_crossobject, chr = 5) %>% .[,"5_2269274"]
hun_cov[hun_cov == 3] <- 0

#NOTE: WT = 1; HUN = 0.

# Create directory to save the results

# dir.create(file.path(paste0(getwd(), "/output"), "qtl_objects"))
# dir.create(file.path(paste0(getwd(), "/output/qtl_objects"), "scanone"))
# dir.create(file.path(paste0(getwd(), "/output/qtl_objects"), "permutations"))
# dir.create(file.path(paste0(getwd(), "/output/tables"), "scanone_summary"))

# calculate the genetic probabilities
ion_crossobject <- calc.genoprob(
  ion_crossobject, 
  step = 0.5
  )

# simulating genotypes
ion_crossobject <- sim.geno(
  ion_crossobject,
  n.draws = 128, 
  step = 0.5, 
  error.prob = 0.001
  )
```
QTL analysis using scanone without covariates
```{r}
######################################################
# Using scanone applying an additive covariate model #
######################################################

scanone.out.hk <- 
  scanone(ion_crossobject, 
          method = "hk",
          pheno.col = ion_pheno.col$pheno.col, 
          )

# save scanone
save(
  list = c("scanone.out.hk"), 
  file = "output/qtl_objects/scanone/scanone.out.hk.RData"
)

load("output/qtl_objects/scanone/scanone.out.hk.RData")

# Permutation test (1000 permutations)
scanone.operm <- 
  scanone(ion_crossobject, 
          method = "hk",
          pheno.col = ion_pheno.col$pheno.col, 
          n.perm = 1000
          )
# save permutation test
save(
  list = c("scanone.operm"), 
  file = "output/qtl_objects/permutations/scanone.operm.RData"
)

load("output/qtl_objects/permutations/scanone.operm.RData")

# Summary, alpha = 0.05
summary(
  scanone.out.hk,
  perms = scanone.operm, 
  alpha = c(0.1), 
  format= "tabByChr",
  ci.function = "bayesint",
  prob = 0.9
  ) 

# transform the summary to tibble
summary_scanone <- summary.to.tibble(
  CROSS = ion_crossobject, 
  SCANONE = scanone.out.hk,
  PERMS = scanone.operm, 
  alpha = 0.1
  )

# Export the summary as a csv
write_csv(
  summary_scanone,
  "output/tables/scanone_summary/summary_scanone.csv"
)

# Create dataframe for lodplots
scanone_lodplot_df <- lodplot_map_df(
  SCANONE = scanone.out.hk,
  SUMMARY = summary_scanone,
  PERMS = scanone.operm,
  alpha = 0.1,
  ci.funciton = "lodint"
  )

scanone_all_plots <- function(data, title) {
  
  plot <- data %>%
    {
        ggplot(
          data =., 
          aes(x = cM, 
              y = lod, 
              group = interaction(chr, alpha)
          )
          ) +
            geom_line(size = 0.75, alpha = 0.3) +
          geom_line(
            aes(alpha = alpha),
            size = 0.75
            ) +
          geom_ribbon(
            aes(ymin = 0, ymax = y), 
            fill = "red", 
            alpha = 0.8
            ) +
          geom_hline( 
            aes(yintercept = unique(threshold)),
            color = "red",
            linetype = 2
            ) +
          scale_alpha_identity() +
          scale_x_continuous(
            name = "chr", 
            breaks = unique(.$breaks), 
            labels = unique(as.character((.$chr)))
            ) +
            theme(
              panel.background = 
                element_rect(
                  fill = "white",
                  colour = "grey50"
                  ),
              text = element_text(size = 20)) +
            ggtitle(title)
    }
  return(plot)
}

# lodplots for all the phenotypes
scanone_lodplot_all <- scanone_lodplot_df %>%
  group_by(phenotype) %>%
  nest %>%
  mutate(
    title = paste0(
      "QTL analysis for simple scanone for ",
      phenotype)) %>%
  mutate(
    plot = map2(
      .x = data, 
      .y = title,
      .f = ~ scanone_all_plots(.x, .y)
    ))

# # create directory for plots
dir.create(file.path(
  paste0(getwd(), "/output/plots"),"scanone_lodplots")
  )

p <- scanone_lodplot_all$plot

# Saving plots into a single pdf
ggsave(
   filename = 
     "output/plots/scanone_lodplots/scanone_lodplot_all.pdf", 
   plot = gridExtra::marrangeGrob(p, nrow=1, ncol=1), 
   width = 15, height = 9
)

# Only significant plots
scanone_lodplot_signif <- scanone_lodplot_all %>%
  semi_join(summary_scanone)

p <- scanone_lodplot_signif$plot

# Saving plots into a single pdf
ggsave(
   filename = 
     "output/plots/scanone_lodplots/scanone_lodplot_signif.pdf", 
   plot = gridExtra::marrangeGrob(p, nrow=1, ncol=1), 
   width = 15, height = 9
)

scanone_signif_single <- function(data, title) {
  plot <- data %>% 
    {
    ggplot(data =., 
           aes(x = cM, 
               y = lod, 
               group = interaction(chr, alpha)
               )
           ) +
      geom_line(
        size = 0.75, 
        alpha = 0.3
        ) +
      geom_line(
        aes(alpha = alpha),
        size = 0.75
                ) +
      geom_ribbon(aes(ymin = 0,
                      ymax = y), 
                  fill = "red", 
                  alpha = 0.8 
                  ) +
      geom_hline(aes(yintercept = threshold),
                 color = "red",
                 linetype = 2) +
      scale_alpha_identity() +
      scale_x_continuous(name = "chr", 
                         breaks = unique(.$breaks),
                         labels = unique(as.character((.$chr)))
                         ) +
      theme(panel.background = element_rect( fill = "white",
                                             colour = "grey50")
            ) +
      ggtitle(title) +
      facet_grid(phenotype ~ .)
    }
  return(plot)
}

# all significant plots in the same page
scanone_lodplot_signif_single <- scanone_lodplot_signif %>%
  select(phenotype, data) %>%
  unnest(data) %>% 
  scanone_signif_single(
    data = .,
    title = "QTL analysis sig peaks scanone"
  )

ggsave(
   filename =
     "output/plots/scanone_lodplots/scanone_lodplot_signif_single.pdf", 
   plot = scanone_lodplot_signif_single, 
   width = 15, 
   height = 18
)
```
QTL analysis with an additive covariate model
```{r}

######################################################
# Using scanone applying an additive covariate model #
######################################################

scanone.addcov.out.hk <- 
  scanone(ion_crossobject, 
          method = "hk",
          pheno.col = ion_pheno.col$pheno.col, 
          addcovar = hun_cov
          )

# save scanone
save(
  list = c("scanone.addcov.out.hk"), 
  file = "output/qtl_objects/scanone/scanone.addcov.out.hk.RData"
)

load("output/qtl_objects/scanone/scanone.addcov.out.hk.RData")

# Permutation test (1000 permutations)
scanone.addcov.operm <- 
  scanone(ion_crossobject, 
          method = "hk",
          pheno.col = ion_pheno.col$pheno.col, 
          addcovar = hun_cov,
          n.perm = 1000
          )
# save permutation test
save(
  list = c("scanone.addcov.operm"), 
  file = "output/qtl_objects/permutations/scanone.addcov.operm.RData"
)

load("output/qtl_objects/permutations/scanone.addcov.operm.RData")

# Summary, alpha = 0.05
summary(
  scanone.addcov.out.hk,
  perms = scanone.addcov.operm, alpha = c(0.05), 
  format= "tabByChr"
  ) 

# transform the summary to tibble
summary_scanone.addcov <- summary.to.tibble(
  CROSS = ion_crossobject, 
  SCANONE = scanone.addcov.out.hk,
  PERMS = scanone.addcov.operm, 
  alpha = 0.1
  )

# Export the summary as a csv
write_csv(
  summary_scanone.addcov,
  "output/tables/scanone_summary/summary_scanone.addcov.csv"
)

# Create dataframe for lodplots
scanone.addcov_lodplot_df <- lodplot_map_df(
  SCANONE = scanone.addcov.out.hk,
  SUMMARY = summary_scanone.addcov,
  PERMS = scanone.addcov.operm,
  alpha = 0.1,
  ci.funciton = "lodint"
  )

# lodplots for all the phenotypes
scanone.addcov_lodplot_all <- scanone.addcov_lodplot_df %>%
  group_by(phenotype) %>%
  nest %>%
  mutate(
    title = paste0(
      "QTL analysis for additive covariate for ",
      phenotype)) %>%
  mutate(
    plot = map2(
      .x = data, 
      .y = title,
      .f = ~ scanone_all_plots(.x, .y)
    ))

p <- scanone.addcov_lodplot_all$plot

# Saving plots into a single pdf
ggsave(
   filename = 
     "output/plots/scanone_lodplots/scanone.addcov_lodplot_all.pdf", 
   plot = gridExtra::marrangeGrob(p, nrow=1, ncol=1), 
   width = 15, height = 9
)

# Only significant plots
scanone.addcov_lodplot_signif <- scanone.addcov_lodplot_all %>%
  semi_join(summary_scanone.addcov)

p <- scanone.addcov_lodplot_signif$plot

# Saving plots into a single pdf
ggsave(
   filename = 
     "output/plots/scanone_lodplots/scanone.addcov_lodplot_signif.pdf", 
   plot = gridExtra::marrangeGrob(p, nrow=1, ncol=1), 
   width = 15, height = 9
)

# all significant plots in the same page
scanone.addcov_lodplot_signif_single <- scanone.addcov_lodplot_signif %>%
  select(phenotype, data) %>%
  unnest(data) %>% 
  scanone_signif_single(
    data = .,
    title = "QTL analysis sig peaks additive covariate"
  )

ggsave(
   filename =
     "output/plots/scanone_lodplots/scanone.addcov_lodplot_signif_single.pdf", 
   plot = scanone.addcov_lodplot_signif_single, 
   width = 15, 
   height = 18
)
```
Assessing the evidence of additive effect of the covariate
```{r}
# Comparing models and looking for evidence for the effect of hun as an additive covariate

# scanone
scanone.addboth.out.hk <- c(
  scanone.out.hk,
  scanone.addcov.out.hk,
  labels = c("nocovar", "covar")
)

# save scanone
save(
  list = c("scanone.addboth.out.hk"), 
  file = "output/qtl_objects/scanone/scanone.addboth.out.hk.RData"
)

# permutations
scanone.addboth.operm <- cbind(
  scanone.operm,
  scanone.addcov.operm,
  labels = c("nocovar", "covar")
)

# save permutation test
save(
  list = c("scanone.addboth.operm"), 
  file = "output/qtl_objects/permutations/scanone.addboth.operm.RData"
)

# load("output/qtl_objects/permutations/ion_int_add.operm.RData")

# Summary
summary(
  scanone.addboth.out.hk, 
  perms = scanone.addboth.operm, 
  alpha = c(0.05), 
  format = "tabByChr"
  )

# transform the summary to tibble
summary_scanone.addboth <- summary.to.tibble(
  CROSS = ion_crossobject, 
  SCANONE = scanone.addboth.out.hk,
  PERMS = scanone.addboth.operm, 
  alpha = 0.1
  )

# Export the summary as a csv
write_csv(
  summary_scanone.addboth,
  "output/tables/scanone_summary/summary_scanone.addboth.csv"
)

# QTLs significant for both scanone and additive covar model
scanone.addcov.both_interesting <- summary_scanone.addboth %>%
  separate(phenotype, into = c("phenotype", "covar"), sep = "\\.") %>%
  group_by(phenotype, chr) %>%
  filter(n() ==2) %>%
  ungroup

write_csv(
  summary_scanone.addboth,
  "output/tables/scanone_summary/scanone.addcov.both_interesting.csv"
)

scanone_all_plots_interesting <- function(data, title) {
  
  plot <- data %>%
    {
      ggplot(
          data =., 
          aes(x = cM, 
              y = lod, 
              color = model,
              group = interaction(chr, alpha, model)
          )
          ) +
            geom_line(size = 0.75, alpha = 0.3) +
          geom_line(
            aes(alpha = alpha),
            size = 0.75
            ) +
          scale_alpha_identity() +
          scale_x_continuous(
            name = "chr", 
            breaks = unique(.$breaks), 
            labels = unique(as.character((.$chr)))
            ) +
            theme(
              panel.background = 
                element_rect(
                  fill = "white",
                  colour = "grey50"
                  ),
              text = element_text(size = 20)) +
            ggtitle(title)
    }
  return(plot)
}

# lodplots for all the phenotypes
scanone.addboth_lodplot_interesting <-bind_rows(
  scanone_lodplot_df %>% mutate(model = "scanone"),
  scanone.addcov_lodplot_df %>% mutate(model = "add")
  ) %>%
  semi_join(scanone.addcov.both_interesting, by = "phenotype") %>%
  group_by(phenotype) %>%
  nest %>%
  mutate(
    title = 
      paste0("QTLs significant for adboth model for ", phenotype)
  ) %>%
  mutate(
    plot = map2(
      .x = data, 
      .y = title,
      .f = ~ scanone_all_plots_interesting(.x, .y)
    )) 

p <- scanone.addcov_lodplot_all$plot

# Saving plots into a single pdf
ggsave(
   filename = 
     "output/plots/scanone_lodplots/scanone.addboth_lodplot_interesting.pdf", 
   plot = gridExtra::marrangeGrob(p, nrow = 1, ncol = 1), 
   width = 15, height = 9
)
```
QTL analysis with an interactive covariate model
```{r}
##################################################
# Using scanone aplying an interactive covariate #
##################################################

scanone.intcov.out.hk <- 
  scanone(ion_crossobject, 
          method = "hk",
          pheno.col = ion_pheno.col$pheno.col, 
          addcovar = hun_cov,
          intcovar = hun_cov
          )

# save scanone
save(
  list = c("scanone.intcov.out.hk"), 
  file = "output/qtl_objects/scanone/scanone.intcov.out.hk.RData"
)

load("output/qtl_objects/scanone/scanone.intcov.out.hk.RData")

# Permutation test
scanone.intcov.operm <- 
  scanone(ion_crossobject, 
          method = "hk",
          pheno.col = ion_pheno.col$pheno.col, 
          addcovar = hun_cov,
          intcovar = hun_cov,
          n.perm = 1000
          )

# save permutation test
save(
  list = c("scanone.intcov.operm"), 
  file = "output/qtl_objects/permutations/scanone.intcov.operm.RData"
)

load("output/qtl_objects/permutations/scanone.intcov.operm.RData")

# Summary 
summary(
  scanone.intcov.out.hk, 
  perms = scanone.intcov.operm, 
  alpha = c(0.1), 
  format= "tabByChr"
  )

# transform the summary to tibble
summary_scanone.intcov <- summary.to.tibble(
  CROSS = ion_crossobject, 
  SCANONE = scanone.intcov.out.hk,
  PERMS = scanone.intcov.operm, 
  alpha = 0.1
  )

# Export the summary as a csv
write_csv(
  summary_scanone.intcov,
  "output/tables/scanone_summary/summary_scanone.intcov"
)

# Create dataframe for lodplots
scanone.intcov_lodplot_df <- lodplot_map_df(
  SCANONE = scanone.intcov.out.hk,
  SUMMARY = summary_scanone.intcov,
  PERMS = scanone.intcov.operm,
  alpha = 0.1,
  ci.funciton = "lodint"
  )

# lodplots for all the phenotypes
scanone.intcov_lodplot_all <- scanone.intcov_lodplot_df %>%
  group_by(phenotype) %>%
  nest %>%
  mutate(
    title = paste0(
      "QTL analysis for additive covariate for ",
      phenotype)) %>%
  mutate(
    plot = map2(
      .x = data, 
      .y = title,
      .f = ~ scanone_all_plots(.x, .y)
    ))

p <- scanone.intcov_lodplot_all$plot

# Saving plots into a single pdf
ggsave(
   filename = 
     "output/plots/scanone_lodplots/scanone.intcov_lodplot_all.pdf", 
   plot = gridExtra::marrangeGrob(p, nrow=1, ncol=1), 
   width = 15, height = 9
)

# Only significant plots
scanone.intcov_lodplot_signif <- scanone.intcov_lodplot_all %>%
  semi_join(summary_scanone.intcov)

p <- scanone.intcov_lodplot_signif$plot

# Saving plots into a single pdf
ggsave(
   filename = 
     "output/plots/scanone_lodplots/scanone.intcov_lodplot_signif.pdf", 
   plot = gridExtra::marrangeGrob(p, nrow=1, ncol=1), 
   width = 15, height = 9
)

# all significant plots in the same page
scanone.intcov_lodplot_signif_single <- scanone.intcov_lodplot_signif %>%
  select(phenotype, data) %>%
  unnest(data) %>% 
  scanone_signif_single(
    data = .,
    title = "QTL analysis sig peaks interactive covariate"
  )

ggsave(
   filename =
     "output/plots/scanone_lodplots/scanone.intcov_lodplot_signif_single.pdf", 
   plot = scanone.intcov_lodplot_signif_single, 
   width = 15, 
   height = 18
)
```
Additive and Interactive models comparison
```{r}
# Comparing models and looking for evidence for interaction between QTLs and HUN covariate

# scanone
scanone.intboth.out.hk <- c(
  scanone.intcov.out.hk,
  scanone.intcov.out.hk - scanone.addcov.out.hk,
  labels = c("f", "i")
)

# save scanone
save(
  list = c("scanone.intboth.out.hk"), 
  file = "output/qtl_objects/scanone/ion_int_add.out.hk.RData"
)

# permutations
scanone.intboth.operm <- cbind(
  scanone.intcov.operm,
  scanone.intcov.operm - scanone.addcov.operm,
  labels = c("f", "i")
)

# save permutation test
save(
  list = c("scanone.intboth.operm"), 
  file = "output/qtl_objects/permutations/scanone.intboth.operm.RData"
)

# load("output/qtl_objects/permutations/ion_int_add.operm.RData")

# Summary
summary(
  scanone.intboth.out.hk, 
  perms = scanone.intboth.operm, 
  alpha = c(0.05), 
  format = "tabByChr"
  )

# transform the summary to tibble
summary_scanone.intboth <- summary.to.tibble(
  CROSS = ion_crossobject, 
  SCANONE = scanone.intboth.out.hk,
  PERMS = scanone.intboth.operm, 
  alpha = 0.05
  )

# Export the summary as a csv
write_csv(
  summary_scanone.intboth,
  "output/tables/scanone_summary/summary_scanone.intboth.csv"
)

summary_scanone.intboth_interesting <- summary_scanone.intboth %>%
  separate(phenotype, into = c("phenotype", "model"), sep = "\\.") %>%
  group_by(phenotype, chr) %>%
  filter(n() == 2) %>%
  arrange(phenotype, model) %>%
  filter(phenotype != "Ni_seed")

# Export the summary as a csv
write_csv(
  summary_scanone.intboth_interesting,
  "output/tables/scanone_summary/summary_scanone.intboth_interesting.csv"
)

# Create dataframe for lodplots
scanone.intboth_lodplot_df <- lodplot_map_df(
  SCANONE = scanone.intboth.out.hk,
  SUMMARY = summary_scanone.intboth,
  PERMS = scanone.intboth.operm,
  alpha = 0.1,
  ci.funciton = "lodint"
  ) %>%
  filter(grepl("\\.i$", phenotype))

# lodplots for all the phenotypes
scanone.intboth_lodplot_all <- scanone.intboth_lodplot_df %>%
  group_by(phenotype) %>%
  nest %>%
  mutate(
    title = paste0(
      "QTL analysis for evidence of hun:QTL interaction for ",
      phenotype)) %>%
  mutate(
    plot = map2(
      .x = data, 
      .y = title,
      .f = ~ scanone_all_plots(.x, .y)
    ))

p <- scanone.intboth_lodplot_all$plot

# Saving plots into a single pdf
ggsave(
   filename = 
     "output/plots/scanone_lodplots/scanone.intboth_lodplot_all.pdf", 
   plot = gridExtra::marrangeGrob(p, nrow=1, ncol=1), 
   width = 15, height = 9
)

# Only significant plots
scanone.intboth_lodplot_signif <- scanone.intboth_lodplot_all %>%
  semi_join(summary_scanone.intboth)

p <- scanone.intboth_lodplot_signif$plot

# Saving plots into a single pdf
ggsave(
   filename = 
     "output/plots/scanone_lodplots/scanone.intboth_lodplot_signif.pdf", 
   plot = gridExtra::marrangeGrob(p, nrow=1, ncol=1), 
   width = 15, height = 9
)

# all significant plots in the same page
scanone.intboth_lodplot_signif_single <- 
  scanone.intboth_lodplot_signif %>%
  select(phenotype, data) %>%
  unnest(data) %>% 
  scanone_signif_single(
    data = .,
    title = "QTL analysis sig peaks evidence of hun:QTL interaction"
  )

ggsave(
   filename =
     "output/plots/scanone_lodplots/scanone.intboth_lodplot_signif_single.pdf", 
   plot = scanone.intboth_lodplot_signif_single, 
   width = 15, 
   height = 18
)
```
Separate analysis on WT families
```{r}
################################
# Analysis on WT families ONLY #
################################

ion_crossobject_WT <- subset(ion_crossobject, ind  = hun_cov == 0)

# scanone for wt individuals
scanone.WT.out.hk <- 
  scanone(ion_crossobject_WT,
          method = "hk",
          pheno.col = ion_pheno.col$pheno.col
          )

load("output/qtl_objects/scanone/scanone.WT.out.hk.RData")

# save scanone
save(
  list = c("scanone.WT.out.hk"), 
  file = "output/qtl_objects/scanone/scanone.WT.out.hk.RData"
)

# Permutation test (1000 permutations) subsetting for wt individuals
scanone.WT.operm <- 
  scanone(ion_crossobject_WT,
          method = "hk",
          pheno.col = ion_pheno.col$pheno.col, 
          n.perm = 1000
          )

# save permutation test
save(
  list = c("scanone.WT.operm"), 
  file = "output/qtl_objects/permutations/scanone.WT.operm.RData"
)

load("output/qtl_objects/permutations/scanone.WT.operm.RData")

# Summary, alpha = 0.05
summary(
  scanone.WT.out.hk,
  perms = scanone.WT.operm,
  alpha = c(0.1), 
  format= "tabByChr"
  ) 

# transform the summary to tibble
summary_scanone.WT <- summary.to.tibble(
  CROSS = ion_crossobject_WT, 
  SCANONE = scanone.WT.out.hk,
  PERMS = scanone.WT.operm, 
  alpha = 0.1
  )

# Export the summary as a csv
write_csv(
  summary_scanone.WT,
  "output/tables/scanone_summary/summary_scanone.WT.csv"
)

# Create dataframe for lodplots
scanone.WT_lodplot_df <- lodplot_map_df(
  SCANONE = scanone.WT.out.hk,
  SUMMARY = summary_scanone.WT,
  PERMS = scanone.WT.operm,
  alpha = 0.1,
  ci.funciton = "lodint"
  )

# lodplots for all the phenotypes
scanone.WT_lodplot_all <- scanone.WT_lodplot_df %>%
  group_by(phenotype) %>%
  nest %>%
  mutate(
    title = paste0(
      "QTL analysis for WT families only for ",
      phenotype)) %>%
  mutate(
    plot = map2(
      .x = data, 
      .y = title,
      .f = ~ scanone_all_plots(.x, .y)
    ))

p <- scanone.WT_lodplot_all$plot

# Saving plots into a single pdf
ggsave(
   filename = 
     "output/plots/scanone_lodplots/scanone.WT_lodplot_all.pdf", 
   plot = gridExtra::marrangeGrob(p, nrow=1, ncol=1), 
   width = 15, height = 9
)

# Only significant plots
scanone.WT_lodplot_signif <- scanone.WT_lodplot_all %>%
  semi_join(summary_scanone.WT)

p <- scanone.WT_lodplot_signif$plot

# Saving plots into a single pdf
ggsave(
   filename = 
     "output/plots/scanone_lodplots/scanone.WT_lodplot_signif.pdf", 
   plot = gridExtra::marrangeGrob(p, nrow=1, ncol=1), 
   width = 15, height = 9
)

# all significant plots in the same page
scanone.WT_lodplot_signif_single <- scanone.WT_lodplot_signif %>%
  select(phenotype, data) %>%
  unnest(data) %>% 
  scanone_signif_single(
    data = .,
    title = "QTL analysis sig peaks WT families only"
  )

ggsave(
   filename =
     "output/plots/scanone_lodplots/scanone.WT_lodplot_signif_single.pdf", 
   plot = scanone.WT_lodplot_signif_single, 
   width = 15, 
   height = 18
)
```
Separate analysis on HUN families
```{r}

#################################
# Analysis on HUN families ONLY #
#################################
ion_crossobject_HUN <- subset(ion_crossobject, ind  = hun_cov == 1)

# scanone for HUN individuals
scanone.HUN.out.hk <- 
  scanone(ion_crossobject_HUN,
          method = "hk",
          pheno.col = ion_pheno.col$pheno.col
          )

# save scanone
save(
  list = c("scanone.HUN.out.hk"), 
  file = "output/qtl_objects/scanone/scanone.HUN.out.hk.RData"
)

load("output/qtl_objects/scanone/scanone.HUN.out.hk.RData")

# Permutation test (1000 permutations) subsetting for HUN individuals
scanone.HUN.operm <- 
  scanone(ion_crossobject_HUN,
          method = "hk",
          pheno.col = ion_pheno.col$pheno.col, 
          n.perm = 1000
          )

# save permutation test
save(
  list = c("scanone.HUN.operm"), 
  file = "output/qtl_objects/permutations/scanone.HUN.operm.RData"
)

load(file = "output/qtl_objects/permutations/scanone.HUN.operm.RData")

# Summary, alpha = 0.05
summary(
  scanone.HUN.out.hk,
  perms = scanone.HUN.operm,
  alpha = c(0.1), 
  format= "tabByChr"
  ) 

# transform the summary to tibble
summary_scanone.HUN <- summary.to.tibble(
  CROSS = ion_crossobject_HUN, 
  SCANONE = scanone.HUN.out.hk,
  PERMS = scanone.HUN.operm, 
  alpha = 0.1
  )

# Export the summary as a csv
write_csv(
  summary_scanone.HUN,
  "output/tables/scanone_summary/summary_scanone.HUN"
)

# Create dataframe for lodplots
scanone.HUN_lodplot_df <- lodplot_map_df(
  SCANONE = scanone.HUN.out.hk,
  SUMMARY = summary_scanone.HUN,
  PERMS = scanone.HUN.operm,
  alpha = 0.1,
  ci.funciton = "lodint"
  )

# lodplots for all the phenotypes
scanone.HUN_lodplot_all <- scanone.HUN_lodplot_df %>%
  group_by(phenotype) %>%
  nest %>%
  mutate(
    title = paste0(
      "QTL analysis for HUN families only for ",
      phenotype)) %>%
  mutate(
    plot = map2(
      .x = data, 
      .y = title,
      .f = ~ scanone_all_plots(.x, .y)
    ))

p <- scanone.HUN_lodplot_all$plot

# Saving plots into a single pdf
ggsave(
   filename = 
     "output/plots/scanone_lodplots/scanone.HUN_lodplot_all.pdf", 
   plot = gridExtra::marrangeGrob(p, nrow=1, ncol=1), 
   width = 15, height = 9
)

# Only significant plots
scanone.HUN_lodplot_signif <- scanone.HUN_lodplot_all %>%
  semi_join(summary_scanone.HUN)

p <- scanone.HUN_lodplot_signif$plot

# Saving plots into a single pdf
ggsave(
   filename = 
     "output/plots/scanone_lodplots/scanone.HUN_lodplot_signif.pdf", 
   plot = gridExtra::marrangeGrob(p, nrow=1, ncol=1), 
   width = 15, height = 9
)

# all significant plots in the same page
scanone.HUN_lodplot_signif_single <- scanone.HUN_lodplot_signif %>%
  select(phenotype, data) %>%
  unnest(data) %>% 
  scanone_signif_single(
    data = .,
    title = "QTL analysis sig peaks HUN families only"
  )

ggsave(
   filename =
     "output/plots/scanone_lodplots/scanone.HUN_lodplot_signif_single.pdf", 
   plot = scanone.HUN_lodplot_signif_single, 
   width = 15, 
   height = 18
)

```
Summary of all qtls detected
```{r}

summary_all_QTLs <- bind_rows(
  summary_scanone %>% mutate(model = "scanone"),
  summary_scanone.addcov %>% mutate(model = "addcov"),
  summary_scanone.intcov %>% mutate(model = "intcov"),
  summary_scanone.intboth %>% mutate(model = "intevidence"),
  summary_scanone.WT %>% mutate(model = "WT"),
  summary_scanone.HUN %>% mutate(model = "HUN")
  ) %>%
  filter(!(model == "intevidence" & grepl("\\.f$", phenotype))) %>%
  mutate(phenotype = ifelse(
    grepl("\\.i$", phenotype),
    gsub("\\.i$", "", phenotype),
    phenotype
    ))

lodplot_all_df <- bind_rows(
  scanone_lodplot_df %>% mutate(model = "scanone"),
  scanone.addcov_lodplot_df %>% mutate(model = "addcov"),
  scanone.intcov_lodplot_df %>% mutate(model = "intcov"),
  scanone.intboth_lodplot_df %>% mutate(model = "intevidence"),
  scanone.WT_lodplot_df %>% mutate(model = "WT"),
  scanone.HUN_lodplot_df %>% mutate(model = "HUN")
  ) %>%
  filter(!(model == "intevidence" & grepl("\\.f$", phenotype))) %>%
  mutate(phenotype = ifelse(
    grepl("\\.i$", phenotype),
    gsub("\\.i$", "", phenotype),
    phenotype
    ))

model_color_scheme <- 
  c(
    "HUN" = "#E41A1C", "WT" = "#000083", "scanone" = "#4DAF4A",
    "addcov" = "#984EA3", "intcov" = "#FF7F00", "intevidence" = "black"
    ) %>%
  enframe(name = "model", value = "color") %>%
  mutate(color = as_factor(color))
  
lodplots_all_models <-  function(data, title) {
  
  plot <- data %>% 
    {
      ggplot(
        data =., 
        aes(x = cM, 
            y = lod, 
            group = interaction(chr, model),
            color = color)
        ) +
        geom_line(
          alpha = 0.25, 
          size = 0.75
          ) +
        geom_line(
          aes(alpha = alpha), 
          size = 0.75
          ) +
        scale_alpha_identity() +
        scale_x_continuous(
          name = NULL, 
          breaks = unique(.$breaks), 
          labels = unique(as.character((.$chr)))
          ) +
        theme(
          panel.background = 
            element_rect(
              fill = "white",
              colour = "grey50"
              ),
          text = element_text(size = 20),
          legend.position = "top",
          plot.title = element_text(hjust = 0.5)) +
        scale_color_identity(
          guide = "legend",
          name = "model",
          breaks = levels(.$color),
          label = levels(.$model)
        ) +
        ggtitle(title)
    }
  return(plot)
  }

lodplots_model_comparisson <- lodplot_all_df %>%
  mutate(breaks = round(breaks, 4)) %>%
  left_join(model_color_scheme) %>%
  mutate(model = factor(
    model,
    levels =  c("HUN", "WT", "scanone", "addcov", "intcov",
                "intevidence"))) %>%
  semi_join(summary_all_QTLs, by = c("model")) %>%
  group_by(phenotype) %>%
  nest %>%
  mutate(title = paste0("All LOD plots for ", phenotype)) %>%
  mutate(data = map(
    .x = data,
    .f = ~ .x %>% droplevels())) %>%
  mutate(plot = map2(
    .x = data, 
    .y = title,
    .f = ~ lodplots_all_models(.x, .y)
    )) 

p <- lodplots_model_comparisson$plot

# Saving plots into a single pdf
ggsave(
   filename = 
     "output/plots/scanone_lodplots/lodplots_model_comparisson.pdf", 
   plot = gridExtra::marrangeGrob(p, nrow = 1, ncol = 1), 
   width = 15, height = 9
)

```

Collapsing QTLs detected in different models into a single range using genomic ranges 

```{r}

interval_granges_list_df <- summary_all_QTLs %>%
  select(seqnames = chr, 
         start = ci.low, 
         end = ci.high,
         phenotype, 
         model)  %>%
  arrange(phenotype, seqnames) %>%
  group_by(phenotype, seqnames) %>%
  filter(n() != 1) %>%
  arrange(phenotype) %>%
  mutate(group = cur_group_id()) 

interval_granges_list <- interval_granges_list_df %>%
  group_split() %>%
  map(.x =., 
      .f = ~ plyranges::as_granges(.x)) %>%
  GRangesList

reduced_intervals <- interval_granges_list %>%
  GenomicRanges::reduce(.) %>%
  as_tibble 

reduced_intervals_info <- interval_granges_list_df %>%
  left_join(
    reduced_intervals,
    by = c("group", "seqnames")
    ) %>%
  group_by(seqnames, phenotype, group) %>%
  select(chr = seqnames, phenotype, group, start.y, end.y, width) %>%
  distinct %>%
  ungroup %>%
  left_join(summary_all_QTLs) %>%
  group_by(group) %>%
  filter(lod == max(lod)) 

qtl_detected_all_reduced <- summary_all_QTLs %>%
  anti_join(reduced_intervals_info, by = c("chr", "phenotype")) %>%
  arrange(phenotype, chr) %>% 
  bind_rows(reduced_intervals_info) %>%
  left_join(summary_scanone.intboth_interesting %>% 
              select(phenotype, chr, model) %>%
              rename(model2 = model)) %>%
    mutate(int = ifelse(!is.na(model2), T, F)) %>%
    select(-model2) %>%
  arrange(phenotype, chr) %>%
  distinct

```

Evaluating multi-QTL models

```{r}

hun <- data.frame(hun = hun_cov)

prepare_fitqtl_df1 <- function(qtls_df) {
  pfitqtldf1 <- qtls_df %>%
    mutate(pos = round(pos,0)) %>%
    arrange(phenotype, chr) %>%
    group_by(phenotype) %>%
    mutate(id = as.character(row_number()),
           term = ifelse(int == F,
                         paste("Q", id, sep =""),
                         paste("hun*Q", id, sep = ""))) %>%
    left_join(ion_pheno.col) %>%
    mutate(chr = as.integer(chr)) %>%
    ungroup
    
    return(pfitqtldf1)
}

prepare_makeqtl <- function(qtls_df, CROSS) {
  pfitqtldf1 <- qtls_df %>%
    group_by(phenotype) %>%
    summarise(
      chr = list(chr), 
      pos = list(pos),
      formula = paste0("y ~ ", paste(term, collapse = "+")),
      formula = paste0(formula, "+hun"),
      pheno.col = dplyr::first(pheno.col)
      ) %>%
    mutate(qtl_model = pmap(
      .l = .,
      .f = ~ with (
        list(...),
        makeqtl(
          cross = CROSS,
          chr = chr,
          pos = pos,
          what = "prob"
      ))))
    
    return(pfitqtldf1)
}

prepare_refqtl <- function(qtls_df, CROSS) {
  pfitqtldf1 <- qtls_df %>%
    mutate(refqtl = 
      pmap(
        .l = .,
        .f = ~ with(
          list(...),
          refineqtl(
            cross = ion_crossobject,
            method = "hk",
            pheno.col =pheno.col,
            qtl = qtl_model,
            formula = formula,
            covar = hun,
            incl.markers = T)
          ))
      )
  return(pfitqtldf1)
}

evaluate_fitqtl <- function(qtls_df, CROSS) {
  
  e_fitqtl_df <- qtls_df %>%
      mutate(fit_qtl = pmap(
      .l = .,
      .f = ~ with (
        list(...),
        fitqtl(
          cross = CROSS,
          pheno.col = pheno.col,
          qtl = refqtl,
          formula = formula, 
          covar = hun,
          method = "hk"
          
        )
      )))
    
  return(e_fitqtl_df)
}

qtl_fullmodel_df <- function(data) {
  
  fmdf <- data %>%
  select(phenotype, refqtl, fit_qtl) %>%
  mutate(
    formula = map_chr(
      .x = fit_qtl,
      .f = ~ .x  %>% attr(., "formula")),
    resultados = map(
      .x = fit_qtl,
      .f = ~ .x %>% 
        .$result.full %>%
        as_tibble(., rownames = "term"))) %>%
  unnest(resultados) %>%
  filter(term == "Model") %>%
  mutate(term = "Full Model",
         qtl = map(.x = refqtl, .f = ~ .x$name )) %>%
  mutate(qtl = ifelse(formula == "y ~ Q1", qtl, "Full Model")) %>%
  unnest(qtl) %>%
  select(-c(refqtl, fit_qtl)) %>%
  dplyr::rename(
    p.Chi2 = `Pvalue(Chi2)`,
    p.F = `Pvalue(F)`
    ) %>%
  mutate(
    s.Chi2 = p.value_to_ast(p.Chi2),
    s.F = p.value_to_ast(p.F),
    ) %>%
  select(phenotype, formula, term, qtl, df, SS, MS, LOD, `%var`,
         contains(".Chi2"), contains(".F")) %>%
  mutate(across( c(df:`%var`), ~ round(., 2)),
         across(c(p.Chi2, p.F), 
                ~ formatC(., format = "e", digits = 2)))
  
  return(fmdf)
}

qtl_dropone_df <- function(data) {
  
  dodf <- data %>%
    select(phenotype, fit_qtl)  %>%
  mutate(
    formula = map_chr(
      .x = fit_qtl,
      .f = ~ .x  %>% attr(., "formula")),
    resultados = map(
      .x = fit_qtl,
      .f = ~ .x %>% .$result.drop %>% as_tibble(., rownames = "qtl")),
    formulas = map(
      .x = fit_qtl,
      .f = ~ .x %>% .$result.drop %>% attr(., "formulas"))) %>%
  unnest(c(resultados, formulas)) %>%
  mutate(term = map2_chr(
    .x = formula,
    .y = formulas,
    .f = ~ Reduce(
      setdiff,
      strsplit(c(.x, .y), split = " ")
      ) %>% .[[1]]
    )) %>%
  select(-fit_qtl) %>%
  dplyr::rename(
    p.Chi2 = `Pvalue(Chi2)`,
    p.F = `Pvalue(F)`) %>%
  mutate(
    s.Chi2 = p.value_to_ast(p.Chi2),
    s.F = p.value_to_ast(p.F),
    term = ifelse(term == "+", "Q1", term)
    ) %>%
  select(phenotype, formula, term, qtl, df:`%var`, contains(".Chi2"),
         contains(".F")) %>%
  mutate(across( c(df:`%var`),
                 ~ round(., 2)),
         across(c(p.Chi2, p.F), 
                ~ formatC(., format = "e", digits = 2)
                )
         ) 
  return(dodf)
  
}

bayes_int_refineqtl <- function(refqtl, qtl.index, CROSS ) {
  
  bie <- refqtl
  
  # Note: change the probablities to prob = 0.9
  
  bayes_df <- bie %>%
  bayesint(.,
           qtl.index = qtl.index, 
           prob = 0.9,
           expandtomarkers = F
           ) %>%
  as_tibble(rownames = "marker") %>% 
  mutate(n = row_number()) %>%
  filter(n == min(n) | n == round(median(n),0) | n == max(n)) %>% 
  select(-n) %>%
  mutate(marker = pmap_chr(
    .l = ., 
    .f = ~ with(
      list(...),
      ifelse(
        !grepl("^(\\d+)\\_", marker),
        find.marker(chr = chr, pos = pos, cross = ion_crossobject),
        marker
        )
      )
    )) %>%
  bind_cols(
    ., 
    tibble(
      gen = c("ci.low", "pos", "ci.high"),
      phys = c("p_pos_l", "p_pos", "p_pos_h"),
      LOD = c("lod_low", "lod", "lod_high")
      )
    ) %>%
  pivot_wider(names_from = gen, values_from = pos) %>%
  pivot_wider(names_from = phys, values_from = marker) %>%
  pivot_wider(names_from = LOD, values_from = lod) %>%
  summarise_all(.funs = list(~na.omit(.))) %>%
  mutate(across(
    where(is.character), 
    ~ round(as.double(gsub("^(\\d+)\\_", "", .))/1e6, 2)
    )) %>%
  mutate(interval = p_pos_h - p_pos_l) %>%
  distinct() %>%
  select(-chr, -lod_low, -lod_high) 
  
  return(bayes_df)
}


multiqtl_refqtl <- qtl_detected_all_reduced %>%
  prepare_fitqtl_df1 %>%
  prepare_makeqtl(., ion_crossobject) %>%
  prepare_refqtl

multiqtl_fitqtl <- multiqtl_refqtl %>%
  evaluate_fitqtl(., ion_crossobject)

multiqtl_fitqtl_results <- bind_rows(
  multiqtl_fitqtl %>% qtl_fullmodel_df,
  multiqtl_fitqtl %>% qtl_dropone_df
  ) %>% 
  arrange(phenotype, term) 

ns_fullmodel_multiqtl <- multiqtl_fitqtl_results %>%
  filter(term == "Full Model") %>%
  filter(s.Chi2 == "NS" | s.F == "NS") %>%
  select(phenotype, formula, term, LOD, `%var`, contains("s."))

ns_terms_multiqtl <- multiqtl_fitqtl_results %>%
  anti_join(ns_fullmodel_multiqtl, by = "phenotype") %>%
  filter(term != "Full Model") %>%
  filter(s.Chi2 == "NS" | s.F == "NS") %>%
  select(phenotype, formula, term, qtl, LOD, `%var`, contains("s.")) %>%
  separate(qtl, into = c("chr", "pos"), sep = "@", remove = F) %>% 
  mutate(chr = gsub("hun(\\:)?", "", chr) %>% trimws)

ns_qtl_multiqtl <- ns_terms_multiqtl %>%
  filter(!grepl("hun(\\:)?", qtl)) 

ns_int_multiqtl <- ns_terms_multiqtl %>%
  filter(grepl("hun\\:", qtl)) %>%
  select(phenotype, chr, term)

# Re-evaluate the models without significant phenotypes, qtls and hun:qtl interactions

multiqtl_refqtl2 <- qtl_detected_all_reduced %>%
  # remove Non-significant phenotypes
  anti_join(ns_fullmodel_multiqtl, by = c("phenotype")) %>%
  # remove non-significant QTLs
  anti_join(ns_qtl_multiqtl, by = c("phenotype", "chr")) %>%
  # remove non-significant interactions 
  left_join(ns_int_multiqtl) %>%
  mutate(int = ifelse(!is.na(term), !int, int)) %>%
  select(-term) %>%
  prepare_fitqtl_df1 %>%
  prepare_makeqtl(., ion_crossobject) %>%
  prepare_refqtl

multiqtl_fitqtl2 <- multiqtl_refqtl2 %>%
  evaluate_fitqtl(., ion_crossobject)

#################################
# Final multi-qtl model results #
#################################
multiqtl_fitqtl_results2 <- bind_rows(
  multiqtl_fitqtl2 %>% qtl_fullmodel_df,
  multiqtl_fitqtl2 %>% qtl_dropone_df
  ) %>% 
  arrange(phenotype, term) 

write_csv(multiqtl_fitqtl_results2, 
          paste0(getwd(),
                 "/output/tables/multiqtl_fitqtl_results.csv"
                 )
)
# Bar plot of the variance explained by the components of the multi-QTL models
var_explained_barplot <- multiqtl_fitqtl_results2 %>%
  filter(term != "Full Model") %>%
  select(phenotype, qtl, var = `%var`) %>%
  mutate(type = ifelse(grepl("@", qtl), "QTL", qtl)) %>%
  group_by(phenotype, type) %>%
  summarise(var = sum(var)) %>%
  ungroup %>%
  mutate(type = factor(type, levels = c("QTL", "hun"))) %>%
  ggplot(data = ., 
         aes(
           x = phenotype,
           y = var,
           fill = type
         )) +
  geom_col() +
  scale_fill_manual(
    guide = "legend",
    name = "Component",
    values = c("#000080", "#EDB120"),
    breaks = c("QTL", "hun"),
    labels = c("QTL additive effect", "HUN")
    ) +
  theme(
    plot.title = element_text(hjust = 0.5),
    legend.position = "top",
    axis.text.x = element_text(angle = 90, vjust = 0.5),
    panel.background = element_rect(
          fill = "white", 
          colour ="grey50"
          ),
    text = element_text(size = 20)
  ) +
  xlab(NULL) +
  ylab("Variance explained (%)") +
  ggtitle("variance explained by the components of the multi-QTL models")

dir.create(file.path(paste0(getwd(), "/output"), "fitqtl_results"))


multiqtl_fitqtl_bayesint <- multiqtl_fitqtl2 %>% 
  select(phenotype, refqtl) %>%
  mutate(QTL = map(.x = refqtl, .f = ~ .x$altname),
         name = map(.x = refqtl, .f = ~ .x$name)) %>%
  unnest(c(QTL, name)) %>%
  group_by(phenotype) %>%
  mutate(qtl_index = row_number()) %>%
  ungroup %>%
  mutate(bayes_int = pmap(
    .l = ., 
    .f = ~ with(
      list(...),
      bayes_int_refineqtl(
        refqtl = refqtl, 
        qtl.index = qtl_index,
        CROSS = ion_crossobject)
      )
    )) %>%
  select(-refqtl) %>%
  unnest(bayes_int)


multiqtl_fitqtl_bayesint2 <- multiqtl_fitqtl2 %>%
  select(phenotype:pheno.col) %>%
  mutate(
    qtl_model = pmap(
      .l =.,
      .f = ~ with(
        list(...),
        makeqtl(
          cross = ion_crossobject,
          chr = chr, 
          pos = pos, 
          what = "draws"
        ))
      )
  ) %>%
  mutate(
    refqtl = pmap(
      .l = .,
      .f = ~ with(
        list(...),
        refineqtl(cross = ion_crossobject,
                  pheno.col = pheno.col,
                  qtl = qtl_model,
                  covar = hun,
                  method = "imp")
      ))
  )
    

multiqtl_fitqtl_bayesint2_2 <- multiqtl_fitqtl_bayesint2 %>%
  select(phenotype, refqtl) %>%
  mutate(QTL = map(.x = refqtl, .f = ~ .x$altname),
         name = map(.x = refqtl, .f = ~ .x$name)) %>%
  unnest(c(QTL, name)) %>%
  group_by(phenotype) %>%
  mutate(qtl_index = row_number()) %>%
  ungroup %>%
  mutate(bayes_int = pmap(
    .l = ., 
    .f = ~ with(
      list(...),
      bayes_int_refineqtl(
        refqtl = refqtl, 
        qtl.index = qtl_index,
        CROSS = ion_crossobject)
      )
    )) %>%
  select(-refqtl) %>%
  unnest(bayes_int)

multiqtl_summary_QTL_all <- multiqtl_fitqtl_bayesint %>%
  dplyr::rename(qtl = name) %>%
  mutate(label = qtl) %>%
  left_join(
    multiqtl_fitqtl_results2, 
    by = c("phenotype", "qtl")
    ) %>% 
  separate(qtl, into = c("chr", NA), sep = "@") %>%
  mutate(chr = as.integer(chr)) %>%
  select(phenotype, label, chr, lod, var = `%var`, sig = s.Chi2,
         pos, ci.low, ci.high, p_pos, p_ci.low = p_pos_l,
         p_ci.high = p_pos_h,interval)

write_csv(multiqtl_summary_QTL_all, 
          paste0(getwd(),
                 "/output/tables/multiqtl_summary_QTL_all.csv"
                 )
)


qtl_lodprofile <- multiqtl_fitqtl2 %>%
  select(phenotype, refqtl) %>%
    mutate(
      df = map(
        .x = refqtl,
        .f = ~ .x %>% 
          attr("lodprofile") %>%
          map_df(
            .,
            .f = ~ as_tibble(., rownames = "marker"), .id = "label"
            ) %>%
          mutate(
            marker = ifelse(!grepl("\\_|\\.", marker),
                            paste0(
                              "c", 
                              as.character(chr), 
                              ".",
                              "loc",
                              as.character(pos)),
                            marker)
            )
        )) %>%
    unnest(df) %>%
  select(-c(refqtl))

mapa_base <- scanone_lodplot_df %>% 
  select(marker, chr, pos, cM, breaks) %>% 
  distinct

qtl_lodprofile_all <- mapa_base %>%
  mutate(chr = as_factor(chr)) %>%
  left_join(qtl_lodprofile) %>%
  left_join(multiqtl_summary_QTL_all %>%
              select(phenotype, label, ci.low, ci.high)) %>%
  filter(!is.na(lod)) %>%
  mutate(y = pmap_dbl(
    .l =.,
    .f = ~ with(
      list(...),
      ifelse(between(pos, ci.low, ci.high),
             lod,
             0)
    )
  )) %>%
  mutate(alpha = ifelse(y == 0, 0.3, 1))


LODprofiles_cM <- qtl_lodprofile_all %>%
  group_by(phenotype) %>%
  mutate(color = ifelse( y == 0, "black", "red" )) %>%
  nest %>%
  mutate(
    title = paste0(
      "multi-qtl LODprofile for ",
      phenotype)) %>%
  mutate(plot = map2(
    .x = data, 
    .y = title,
    .f = ~ .x %>%
      {
        ggplot(
          data =., 
          aes(x = cM, 
              y = lod, 
              group = interaction(chr),
              color = color
          )
          ) +
            geom_line(size = 0.75, alpha = 0.3) +
          geom_line(
            aes(alpha = alpha),
            size = 0.75
            ) +
          scale_alpha_identity() +
          scale_color_identity() +
          scale_x_continuous(
            name = "chr", 
            breaks = unique(.$breaks), 
            labels = unique(as.character((.$chr)))
            ) +
            theme(
              panel.background = 
                element_rect(
                  fill = "white",
                  colour = "grey50"
                  ),
              text = element_text(size = 20),
              plot.title = element_text(hjust = 0.5)) +
      ggtitle(.y)
      }
  )) 

bind_rows(
  qtl_lodprofile_all %>% mutate(model = "multiqtl"),
  scanone.WT_lodplot_df %>% 
    mutate(chr = as_factor(chr), model = "WT")) %>%
  semi_join(., summary_scanone.WT, by = c("phenotype")) %>%
  group_by(phenotype) %>%
  mutate(color = ifelse( y == 0 | is.na(y), "black", "red" )) %>%
  select(phenotype, cM, lod, chr, color, alpha, breaks, model) %>%
  nest %>%
  mutate(
    title = paste0(
      "multi-qtl LODprofile for ",
      phenotype)) %>%
  mutate(plot = map2(
    .x = data, 
    .y = title,
    .f = ~ .x %>%
      {
        ggplot(
          data =., 
          aes(x = cM, 
              y = lod, 
              group = chr,
              color = color
          )
          ) +
            geom_line(size = 0.75, alpha = 0.3) +
          geom_line(
            aes(alpha = alpha),
            size = 0.75
            ) +
          scale_alpha_identity() +
          scale_color_identity() +
          scale_x_continuous(
            name = "chr", 
            breaks = unique(.$breaks), 
            labels = unique(as.character((.$chr)))
            ) +
            theme(
              panel.background = 
                element_rect(
                  fill = "white",
                  colour = "grey50"
                  ),
              text = element_text(size = 20),
              plot.title = element_text(hjust = 0.5)) +
      ggtitle(.y) +
          facet_grid(model ~ .)
      }
  )) %>%
  .$plot %>% 
  .[[4]]



qtl_lodprofile_wrap <- qtl_lodprofile_all %>%
  mutate(chr2 = chr) %>%
  group_by(phenotype, chr2) %>%
  nest %>%
  arrange(phenotype, chr2)%>%
  mutate(plot = map(
    .x = data,
    .f = ~ .x %>%
      ggplot(data =., aes(x = pos, y = lod)) +
      geom_ribbon(
        aes(ymin = 0, ymax = y), 
        fill = "#ff0000", 
        alpha = 0.6
        ) + 
      xlab(NULL) +
      ylab(NULL) +
      geom_line(size = 1) +
      theme(
        panel.background = element_rect(
          fill = "white", 
          colour ="grey50"
          )) +
      facet_wrap(. ~ chr)
  )) %>%
  group_by(phenotype) %>%
  summarise(plot = list(plot)) %>%
  mutate(wrap = map(
    .x = plot, 
    .f = ~ patchwork::wrap_plots(
      .x, 
      guides = "collect",
      nrow = 1
      ) +
      plot_annotation( 
        theme = theme(plot.title = element_text(hjust = 0.5)
                      ) 
        )
    )) 
  

```

Correlations between traits

```{r}

reorder_cormat <- function(cormat){
# Use correlation between variables as distance
dd <- as.dist((1-cormat)/2)
hc <- hclust(dd)
cormat <-cormat[hc$order, hc$order]
}

# Get lower triangle of the correlation matrix
get_lower_tri<-function(cormat){
    cormat[upper.tri(cormat)] <- NA
    return(cormat)
  }
# Get upper triangle of the correlation matrix
get_upper_tri <- function(cormat){
    cormat[lower.tri(cormat)]<- NA
    return(cormat)
}
reorder_cormat <- function(cormat){
# Use correlation between variables as distance
dd <- as.dist((1-cormat)/2)
hc <- hclust(dd)
cormat <-cormat[hc$order, hc$order]
}
  

  
corr.matrix.WT.leaf <- ionomics_phenotypes %>%
  mutate(tissue = tolower(tissue)) %>% 
  filter(hun == "WT" & tissue == "leaf") %>%
  pivot_wider(names_from = ion, values_from = value) %>%
  select(-c(id:tissue)) %>%
  cor(.) %>%
  round(., 2) %>%
  get_upper_tri %>%
  as_tibble(rownames = "ion") %>%
  pivot_longer(-ion, names_to = "ion2") %>%
  filter(ion != ion2) %>%
  filter(!is.na(value)) %>%
  mutate(hun = "WT")

corr.matrix.HUN.leaf <- ionomics_phenotypes %>%
  mutate(tissue = tolower(tissue)) %>% 
  filter(hun == "HUN" & tissue == "leaf") %>%
  pivot_wider(names_from = ion, values_from = value) %>%
  select(-c(id:tissue)) %>%
  cor(., use = "complete.obs") %>%
  round(., 2) %>%
  get_upper_tri %>%
  as_tibble(rownames = "ion") %>%
  pivot_longer(-ion, names_to = "ion2") %>%
  filter(ion != ion2) %>%
  filter(!is.na(value)) %>%
  mutate(hun = "HUN")

bind_rows(corr.matrix.WT.leaf,
          corr.matrix.HUN.leaf) %>% 
  pivot_wider(names_from = hun, values_from = value) %>%
  mutate(change_sign = WT * HUN) %>%
  filter(change_sign < 0) %>%
  arrange(ion)  


leaf.corr.matrix <- matrix(NA, nrow = 20, ncol = 20)
leaf.corr.matrix[upper.tri(leaf.corr.matrix)] <-
  corr.matrix.WT.leaf[upper.tri(corr.matrix.WT.leaf)]

leaf.corr.matrix[lower.tri(leaf.corr.matrix)] <-
  corr.matrix.HUN.leaf[lower.tri(corr.matrix.HUN.leaf)]

rownames(leaf.corr.matrix) <-  rownames(corr.matrix.WT.leaf)
colnames(leaf.corr.matrix) <-  colnames(corr.matrix.WT.leaf)

leaf.corr.matrix %>%
  ggcorrplot(., hc.order = TRUE, outline.col = "white") +
  theme(title = element_text(hjust = 0.5)) +
  scale_y_continuous(sec.axis = dup_axis()) +
    ggtitle("correlation between elements in WT and HUN families for leaf tissue")

corr.matrix.HUN.leaf %>%
  as_tibble(rownames = "ion") %>%
  pivot_longer(names)
  
  

  
  

  reshape2::melt(., na.rm = TRUE) %>%
  mutate(abs = abs(value)) %>%
  filter(Var1 != Var2) %>%
  arrange(desc(abs)) %>%  view
  ggcorrplot(., hc.order = TRUE, type = "lower",
     outline.col = "white") %>%
  
  melt(., na.rm = TRUE) %>%
  as_tibble() %>%
  rename(ion = Var1, ion2 = Var2, r2 = value) %>%
  ggplot(data = ., aes(ion2, ion, fill = r2))+
 geom_tile(color = "white")+
 scale_fill_gradient2(low = "blue", high = "red", mid = "white", 
   midpoint = 0, limit = c(-1,1), space = "Lab", 
   name="Pearson\nCorrelation") +
  theme_minimal()+ 
 theme(axis.text.x = element_text(angle = 45, vjust = 1, 
    size = 12, hjust = 1))+
 coord_fixed()

corr.matrix.WT.seed <- ionomics_phenotypes %>%
  mutate(tissue = tolower(tissue)) %>% 
  filter(hun == "WT" & tissue == "seed") %>%
  pivot_wider(names_from = ion, values_from = value) %>%
  select(-c(id:tissue)) %>%
  cor(.) %>%
  flattenCorrMatrix %>%
  arrange(row, column)

corr.matrix.HUN.seed <- ionomics_phenotypes %>%
  mutate(tissue = tolower(tissue)) %>% 
  filter(hun == "HUN" & tissue == "seed") %>%
  pivot_wider(names_from = ion, values_from = value) %>%
  select(-c(id:tissue)) %>%
  cor(.) %>%
  flattenCorrMatrix %>%
  arrange(row, column)

corr.matrix.WT.leaf %>%
  ggplot(
    data =., 
    aes(
      x = row,
      y = column,
      fill = cor)) +
  geom_tile() +
  theme(
      panel.background = element_rect(fill = "white", 
                                      colour ="grey50"),
      plot.title = element_text(hjust = 0.5),
      text = element_text(size=20)
      )
```

Probable conditional QTLs (detected in either WT or HUN dataset, but not in the other)

```{r}

summary_scanone.WT %>%
  mutate(chr = as.integer(chr)) %>%
  left_join(multiqtl_summary_QTL_all, by = c("phenotype", "chr")) %>% 
  select(phenotype, sort(names(.))) %>% 
  select(
    phenotype,
    chr, 
    contains("interval"),
    matches("^pos\\.(x|y)$|^ci\\.high\\.(x|y)$|^ci\\.low\\.(x|y)$")
    ) %>%
  left_join(., ion_pheno.col)

WT_refqtl <- summary_scanone.WT %>%
  arrange(phenotype, chr) %>%
  mutate(int = T) %>%
  prepare_fitqtl_df1 %>%
  prepare_makeqtl(., ion_crossobject) %>%
  prepare_refqtl

WT_fitqtl <- WT_refqtl %>%
  evaluate_fitqtl(., ion_crossobject)

WT_fitqtl_results2 <- bind_rows(
  WT_fitqtl %>% qtl_fullmodel_df,
  WT_fitqtl %>% qtl_dropone_df
  ) %>% 
  arrange(phenotype, term) 

HUN_refqtl <- summary_scanone.HUN %>%
  arrange(phenotype, chr) %>%
  mutate(int = T) %>%
  prepare_fitqtl_df1 %>%
  prepare_makeqtl(., ion_crossobject) %>%
  prepare_refqtl

HUN_fitqtl <- HUN_refqtl %>%
  evaluate_fitqtl(., ion_crossobject)

HUN_fitqtl_results2 <- bind_rows(
  HUN_fitqtl %>% qtl_fullmodel_df,
  HUN_fitqtl %>% qtl_dropone_df
  ) %>% 
  arrange(phenotype, term) 


write_csv(multiqtl_fitqtl_results2, 
          paste0(getwd(),
                 "/output/tables/multiqtl_fitqtl_results.csv"
                 )
)

summary_scanone.HUN %>%
  arrange(phenotype, chr)

scanone.WT.out.hk %>% plot(., lodcolumn = 28)
plot(.)


```

Effectplots in whole set and HUN and WT sets separated

```{r}

genotypes_scheme_color <- c("CML312" = "#e77e39", 
                            "HET" = "#9a3a28",
                            "W22" = "#2e1342")

all_qtl_x_efplots_df <- bind_rows(
  multiqtl_summary_QTL_all  %>% mutate(what = "ALL"), 
  summary_scanone.WT %>% mutate(what = "WT", chr = as.integer(chr)),
  summary_scanone.HUN %>% mutate(what = "HUN", chr = as.integer(chr))
  ) %>%
  select(phenotype, chr, pos, what) %>%
  arrange(phenotype, chr) %>%
  group_by(phenotype, chr) %>%
  filter(n() == 1 | (n() != 1 & what != "ALL")) %>%
  ungroup %>%
  mutate(pos = round(pos, 1)) %>%
  mutate(qtl = paste0(chr, "@", pos)) %>%
  left_join(ion_pheno.col)
  

effectplot_whole.lines <- all_qtl_x_efplots_df %>%
  mutate(ep = pmap(
    .l = .,
    .f = ~ with( 
      list(...),
      effectplot(cross = ion_crossobject,
                 pheno.col = pheno.col, 
                 mname1 = qtl, 
                 draw = F)
      )))

effectplot_HUN <- all_qtl_x_efplots_df %>%
  filter(!(chr == 5 & between(pos, 0, 5))) %>%
  mutate(ep = pmap(
    .l = .,
    .f = ~ with( 
      list(...),
      effectplot(cross = ion_crossobject_HUN,
                 pheno.col = pheno.col, 
                 mname1 = qtl, 
                 draw = F)
      )))

effectplot_WT <- all_qtl_x_efplots_df %>%
  filter(!(chr == 5 & between(pos, 0, 5))) %>%
  mutate(ep = pmap(
    .l = .,
    .f = ~ with( 
      list(...),
      effectplot(cross = ion_crossobject_WT,
                 pheno.col = pheno.col, 
                 mname1 = qtl, 
                 draw = F)
      )))

effectplots_all_hun_wt_df <- bind_rows(
  effectplot_whole.lines %>% mutate(what = "All"),
  effectplot_HUN %>% mutate(what = "HUN"),
  effectplot_WT %>% mutate(what = "WT")
) %>%
  mutate(ep_df = map( 
    .x = ep,
    .f = ~ map_df(.x =., .f = ~enframe(.x), .id = "what") %>%
      mutate(name = str_extract(name, "[A-Z0-9]{1,}$")) %>%
      pivot_wider(names_from = what, values_from = value) %>%
      mutate(name = case_when(name == "CMLCML" ~ "CML312",
                              name == "CMLW22" ~ "HET",
                              name == "W22W22" ~ "W22",
                              T ~ NA_character_)))) %>%
  select(-ep) %>%
  unnest(ep_df) 

effectplots_all_hun_wt <- effectplots_all_hun_wt_df %>%
  mutate(label = paste0(chr, "@", pos)) %>%
  group_by(what, phenotype, chr, label) %>%
  nest %>%
  arrange(phenotype, chr, what) %>%
  mutate(plot = map2(
    .x = data,
    .y = what,
    .f =  ~regular_effecplots_function(.x, .y) 
    ))

effectplots_all_hun_wt_wrap <- effectplots_all_hun_wt %>%
  mutate(what = factor(what, levels = c("HUN", "WT", "All"))) %>%
  arrange(phenotype, chr, what) %>%
  group_by(phenotype, chr, label) %>%
  summarise(plot = list(plot)) %>%
  mutate(wrap = map(
    .x = plot, 
    .f = ~ 
      wrap_plots(
        .x, 
        guides = "collect") +
      plot_annotation(
        theme = theme(plot.title = element_text(hjust = 0.5),
        text = element_text(size=20)
                      )
        )))

effectplot_cov <- all_qtl_x_efplots_df %>%
  mutate(ep = pmap(
    .l = .,
    .f = ~ with( 
      list(...),
      effectplot(cross = ion_crossobject, pheno.col = pheno.col, 
                 mname1 = "5_2269274", mname2 = qtl, draw = F))))

effectplots_cov_df <- effectplot_cov %>%
  mutate(
    ep_df = map(
      .x = ep,
      .f = ~ map_df(
        .x =., 
        .f = ~ as_tibble(.x, rownames = "hun"), 
        .id = "what") %>%
  pivot_longer(-c(what, hun)) %>%
  pivot_wider(names_from = what, values_from = value) %>%
  filter(!grepl("CMLW22", hun)) %>%
  mutate(across(c(hun, name), ~ str_extract(., "[A-Z0-9]{1,}$"))) %>%
  mutate(hun = ifelse(hun == "CMLCML", "WT", "HUN"),
         name = case_when(name == "CMLCML" ~ "CML312",
                          name == "CMLW22" ~ "HET",
                          name == "W22W22" ~ "W22",
                          T ~ NA_character_)) %>%
  mutate(hun = factor(hun, levels = c("WT", "HUN"))) 
  )) %>%
  select(-ep) %>%
  unnest(ep_df) 

effectplots_cov <- effectplots_cov_df %>%
  mutate(label = paste0(chr, "@", pos)) %>%
  group_by(phenotype, chr, label) %>%
  nest %>% 
  mutate(plot = map2(
    .x = data,
    .y = "COV",
    .f = ~ cov_effecplots_function(.x, .y)
    )) %>%
  select(-data)
  

cov_effecplots_function <- function(data, title) {
  
  PLOT <- data %>%
    ggplot(
    data =., 
    aes(x = hun, 
        y = Means,
        group =  name,
        color = name
        )
    ) +
  geom_errorbar(
    aes(
      ymin = Means - SEs,
      ymax = Means + SEs
      ),
    width = 0.2, 
    size = 1
    ) +
  geom_line(
    size = 1
    ) +
  geom_point(
    size = 2, 
    shape = 22, 
    fill = "white"
    ) +
  scale_color_manual(
    guide = NULL,
    values = genotypes_scheme_color
    ) +
  xlab(NULL) +
  ylab("ppm") +
  theme(
        panel.background = element_rect(
          fill = "white", 
          colour ="grey50"
          ),
        plot.title = element_text(hjust = 0.5),
        text = element_text(size=20)
        ) +
    ggtitle(title) +
    facet_wrap(. ~ qtl)
  
  return(PLOT)
}
regular_effecplots_function <- function(data, title) {
  
  plot <-  data %>% 
    ggplot(data =., aes(x = name, y = Means, color = name))  +
    geom_errorbar(
      aes(ymin = Means - SEs , ymax = Means + SEs),
      width = 0.2, 
      size = 1
      ) +
    geom_point(
      size = 2,
      shape = 22, 
      fill = "white"
      ) +
    scale_color_manual(
      name = "Genotype",
      values = genotypes_scheme_color
      ) +
    xlab(NULL) +
    ylab("ppm") +
    theme(
      panel.background = element_rect(
        fill = "white", 
        colour ="grey50"),
      plot.title = element_text(hjust = 0.5),
      text = element_text(size=20)) +
    ggtitle(title)
  return(plot)
}

effectplots_all_same_y <- effectplots_all_hun_wt %>%
  mutate(what2 = "all") %>%
  bind_rows(effectplots_cov %>% mutate(what2 = "cov")) %>%
  select(-data) %>%
  arrange(phenotype, chr,  what2) %>%
  mutate(
    margenes = map(
      .x = plot,
      .f = ~ ggplot_build(.x)$layout$panel_scales_y[[1]]$range$range)
  ) %>%
  unnest(margenes) %>%
  group_by(phenotype, chr) %>%
  mutate(min = min(margenes),
         max = max(margenes)) %>%
  pivot_longer(c(min, max), names_to = NULL) %>%
  select(-margenes) %>%
  distinct %>%
  group_by(phenotype, chr, what, label, plot, what2) %>%
  summarise(margenes = list(value)) %>%
  mutate(plot2 = map2(
    .x = plot, 
    .y = margenes, 
    .f = ~ .x + coord_cartesian(ylim = .y))) 
  
effectplots_all_patchwork <- effectplots_all_same_y %>%
  mutate(what = factor(what, levels = c("HUN", "WT", "All"))) %>%
  arrange(phenotype, chr, what) %>%
  group_by(phenotype, chr, label, what2) %>%
  summarise(plot = list(plot2)) %>%
  mutate(wrap = map(
    .x = plot, 
    .f = ~ 
      wrap_plots(
        .x, 
        guides = "collect") +
      plot_annotation(
        theme = theme(plot.title = element_text(hjust = 0.5),
        text = element_text(size=20)
                      )
        )))  %>%
  select(-plot) %>%
  pivot_wider(names_from = what2, values_from = wrap) %>%
  ungroup %>%
  mutate(patch2 = pmap(
    .l =.,
    .f = ~ with(
      list(...),
      all + 
        cov + 
        plot_layout(guides = "collect", nrow = 1) +
            plot_annotation( 
              title = label, 
              theme = theme(plot.title = element_text(hjust = 0.5),
                            text = element_text(size=16)
                            ) 
              ) &
            theme(legend.position = "bottom",
                  text = element_text(size=16))
    )
  )) %>%
  select(phenotype:label, patch2) %>%
  group_by(phenotype) %>%
  mutate(n = n()) %>%
  summarise(patch2 = list(patch2),
            n = first(n)) %>%
  mutate(patch3 = pmap(
    .l = .,
    .f = ~ with(
      list(...),
      wrap_plots(patch2, guides = "collect", nrow = n) +
        plot_annotation( 
              title = phenotype, 
              theme = theme(plot.title = element_text(hjust = 0.5),
                            text = element_text( size = 20)
                            ) 
        
      ))
    ))  

p <- effectplots_all_patchwork$patch3

# # create directory for plots
# dir.create(file.path(paste0(getwd(), "/output/plots"), "effectplots"))

# Saving plots into a single pdf
pdf("output/plots/effectplots/all_comparisson.pdf",
    onefile = TRUE,
    width = 15, 
    height = 9
    )
walk(p, ~ print(.x))
dev.off()


```


```{r}
